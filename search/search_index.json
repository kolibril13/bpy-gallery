{"config":{"lang":["en"],"separator":"[\\s\\-_,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bpy Gallery","text":"<p>Welcome to this Documentation, where you'll find curated examples on how to use Blender with python notebooks. If you find these resources useful, you're welcome to give a \u2b50 a on GitHub : https://github.com/kolibril13/ipyblender-experimental You can also support my work by buying me a coffe:</p>"},{"location":"n1a_objects/","title":"Adding Objects","text":"In\u00a0[1]: Copied! <pre>import bpy\nfrom IPython.display import display, Image\n\ndef fresh_scene(keep_cube=False):\n    # Deselect all objects\n    bpy.ops.object.select_all(action='DESELECT')\n    \n    # Select all objects except cameras and optionally the default cube\n    for obj in bpy.context.scene.objects:\n        if obj.type == 'CAMERA':\n            obj.select_set(False)\n        elif obj.name == 'Cube' and keep_cube:\n            obj.select_set(False)\n        else:\n            obj.select_set(True)\n    \n    bpy.ops.object.delete()\n    \n    # Add light\n    bpy.ops.object.light_add(type='SUN')\n    sun = bpy.context.object\n\n    sun.location = (0, 0, 0)\n    from math import radians\n    sun.rotation_euler = (radians(204), radians(-133), radians(-67))\n    sun.data.energy = 5  \n\n\ndef render_result():\n    bpy.ops.render.render()\n    bpy.data.images['Render Result'].save_render(filepath=\"img.png\")\n    display(Image(filename=\"img.png\"))\n\nbpy.context.scene.render.resolution_x = 500\nbpy.context.scene.render.resolution_y = 200\n</pre> import bpy from IPython.display import display, Image  def fresh_scene(keep_cube=False):     # Deselect all objects     bpy.ops.object.select_all(action='DESELECT')          # Select all objects except cameras and optionally the default cube     for obj in bpy.context.scene.objects:         if obj.type == 'CAMERA':             obj.select_set(False)         elif obj.name == 'Cube' and keep_cube:             obj.select_set(False)         else:             obj.select_set(True)          bpy.ops.object.delete()          # Add light     bpy.ops.object.light_add(type='SUN')     sun = bpy.context.object      sun.location = (0, 0, 0)     from math import radians     sun.rotation_euler = (radians(204), radians(-133), radians(-67))     sun.data.energy = 5     def render_result():     bpy.ops.render.render()     bpy.data.images['Render Result'].save_render(filepath=\"img.png\")     display(Image(filename=\"img.png\"))  bpy.context.scene.render.resolution_x = 500 bpy.context.scene.render.resolution_y = 200 In\u00a0[3]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_monkey_add(size=2.5, location=(0, 0, 0))\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_monkey_add(size=2.5, location=(0, 0, 0)) render_result() In\u00a0[4]: Copied! <pre>fresh_scene()\nbpy.ops.object.gpencil_add(location=(0, 0, 0), type='STROKE')\ngpencil_object = bpy.context.active_object\ngpencil_object.scale = (3, 3, 3)\n\nrender_result()\n</pre> fresh_scene() bpy.ops.object.gpencil_add(location=(0, 0, 0), type='STROKE') gpencil_object = bpy.context.active_object gpencil_object.scale = (3, 3, 3)  render_result() In\u00a0[5]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, location=(0, 0, 0))  render_result() In\u00a0[6]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cone_add(radius1=1, depth=2, location=(0, 0, 0))  \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cone_add(radius1=1, depth=2, location=(0, 0, 0))   render_result() In\u00a0[7]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(0, 0, 0))  render_result() In\u00a0[8]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_torus_add(major_radius=2, minor_radius=0.3, location=(0,0, 0))\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_torus_add(major_radius=2, minor_radius=0.3, location=(0,0, 0)) render_result() In\u00a0[9]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_ico_sphere_add(radius=1, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_ico_sphere_add(radius=1, location=(0, 0, 0))  render_result() In\u00a0[10]: Copied! <pre>fresh_scene()\nbpy.ops.object.text_add(location=(-4, 0, 0))\nbpy.context.object.data.body = \"Hello \ud83d\ude04\"\nbpy.context.object.scale = (2, 2, 2)\nrender_result()\n</pre> fresh_scene() bpy.ops.object.text_add(location=(-4, 0, 0)) bpy.context.object.data.body = \"Hello \ud83d\ude04\" bpy.context.object.scale = (2, 2, 2) render_result() In\u00a0[11]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_plane_add(size=3, location=(0, 0, 0))  \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_plane_add(size=3, location=(0, 0, 0))   render_result() In\u00a0[12]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_circle_add(radius=2.5, location=(0, 0, 0), fill_type='NGON')\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_circle_add(radius=2.5, location=(0, 0, 0), fill_type='NGON') render_result() In\u00a0[13]: Copied! <pre>fresh_scene()\nbpy.ops.object.empty_add(type='PLAIN_AXES', location=(4, 0, 0)) # (This is not shown in the image, but it is there :) )\nrender_result()\n</pre> fresh_scene() bpy.ops.object.empty_add(type='PLAIN_AXES', location=(4, 0, 0)) # (This is not shown in the image, but it is there :) ) render_result() In\u00a0[14]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))  render_result() In\u00a0[15]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) \nlight = bpy.data.objects.new(\"Light\", bpy.data.lights.new(\"Light\", 'POINT'))\nlight.location = (3, 0, 2)\nlight.data.energy = 8000\nbpy.context.collection.objects.link(light)\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))  light = bpy.data.objects.new(\"Light\", bpy.data.lights.new(\"Light\", 'POINT')) light.location = (3, 0, 2) light.data.energy = 8000 bpy.context.collection.objects.link(light) render_result() In\u00a0[16]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) \ncube = bpy.context.active_object\nbevel_modifier = cube.modifiers.new(name=\"Bevel\", type='BEVEL')\nbevel_modifier.width = 0.3  # Adjust the bevel width\nbevel_modifier.segments = 5  # Number of segments for a smoother bevel\n\n# Optionally apply the modifier if needed (not necessary for visualization)\n# bpy.ops.object.modifier_apply(modifier=\"Bevel\")\n\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))  cube = bpy.context.active_object bevel_modifier = cube.modifiers.new(name=\"Bevel\", type='BEVEL') bevel_modifier.width = 0.3  # Adjust the bevel width bevel_modifier.segments = 5  # Number of segments for a smoother bevel  # Optionally apply the modifier if needed (not necessary for visualization) # bpy.ops.object.modifier_apply(modifier=\"Bevel\")  render_result() In\u00a0[17]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create the subdivision surface modifier and change it to 'SIMPLE'\nsubsurf_modifier = cube.modifiers.new(name=\"Subdivision\", type='SUBSURF')\nsubsurf_modifier.subdivision_type = 'SIMPLE'  # Change to 'SIMPLE' instead of 'CATMULL_CLARK'\nsubsurf_modifier.levels = 4  # Viewport subdivision level\nsubsurf_modifier.render_levels = 4  # Render subdivision level\n\ndisplace_modifier = cube.modifiers.new(name=\"Displace\", type='DISPLACE')\ndisplace_modifier.strength = 0.5  # Adjust the displacement strength\n\ntexture = bpy.data.textures.new(\"DisplaceTexture\", type='CLOUDS')\ntexture.noise_scale = 1  # Reduce the noise scale to make it more detailed\ndisplace_modifier.texture = texture  # Assign the texture to the modifier\n\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create the subdivision surface modifier and change it to 'SIMPLE' subsurf_modifier = cube.modifiers.new(name=\"Subdivision\", type='SUBSURF') subsurf_modifier.subdivision_type = 'SIMPLE'  # Change to 'SIMPLE' instead of 'CATMULL_CLARK' subsurf_modifier.levels = 4  # Viewport subdivision level subsurf_modifier.render_levels = 4  # Render subdivision level  displace_modifier = cube.modifiers.new(name=\"Displace\", type='DISPLACE') displace_modifier.strength = 0.5  # Adjust the displacement strength  texture = bpy.data.textures.new(\"DisplaceTexture\", type='CLOUDS') texture.noise_scale = 1  # Reduce the noise scale to make it more detailed displace_modifier.texture = texture  # Assign the texture to the modifier  render_result() In\u00a0[18]: Copied! <pre># current blender version\nbpy.app.version_string\n</pre> # current blender version bpy.app.version_string Out[18]: <pre>'4.2.3 LTS'</pre> In\u00a0[19]: Copied! <pre># current blender version\nbpy.context.scene.render.engine\n</pre> # current blender version bpy.context.scene.render.engine Out[19]: <pre>'BLENDER_EEVEE_NEXT'</pre> In\u00a0[20]: Copied! <pre>bpy.context.scene.render.resolution_x, bpy.context.scene.render.resolution_y\n</pre> bpy.context.scene.render.resolution_x, bpy.context.scene.render.resolution_y Out[20]: <pre>(500, 200)</pre> In\u00a0[21]: Copied! <pre>bpy.context.scene.name\n</pre> bpy.context.scene.name Out[21]: <pre>'Scene'</pre> In\u00a0[22]: Copied! <pre>bpy.context.active_object.name\n</pre> bpy.context.active_object.name Out[22]: <pre>'Cube'</pre> In\u00a0[23]: Copied! <pre>bpy.context.active_object.location\n</pre> bpy.context.active_object.location Out[23]: <pre>Vector((0.0, 0.0, 0.0))</pre> In\u00a0[24]: Copied! <pre>bpy.context.collection.objects.keys()\n</pre> bpy.context.collection.objects.keys() Out[24]: <pre>['Camera', 'Sun', 'Cube']</pre> In\u00a0[25]: Copied! <pre>bpy.context.collection.objects.values()\n</pre> bpy.context.collection.objects.values() Out[25]: <pre>[bpy.data.objects['Camera'], bpy.data.objects['Sun'], bpy.data.objects['Cube']]</pre> In\u00a0[26]: Copied! <pre>fresh_scene()\n\n# Add a cube\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create and assign a green material to the cube without using nodes\nmat = bpy.data.materials.new(name=\"GreenMaterial\")\nmat.diffuse_color = (0, 1, 0, 1)  # Green color (R, G, B, A)\n\n# Apply material to the cube\ncube.data.materials.clear()  # Clear any existing materials\ncube.data.materials.append(mat)\n\nrender_result()\n</pre> fresh_scene()  # Add a cube bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create and assign a green material to the cube without using nodes mat = bpy.data.materials.new(name=\"GreenMaterial\") mat.diffuse_color = (0, 1, 0, 1)  # Green color (R, G, B, A)  # Apply material to the cube cube.data.materials.clear()  # Clear any existing materials cube.data.materials.append(mat)  render_result() In\u00a0[27]: Copied! <pre>fresh_scene()\n\n# colors with nodes\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create and assign a blue material to the cube\nmat = bpy.data.materials.new(name=\"BlueMaterial\")\nmat.use_nodes = True\nbsdf = mat.node_tree.nodes.get('Principled BSDF')\nbsdf.inputs['Base Color'].default_value = (0, 0, 1, 1)  # Blue color (R, G, B, A)\n\n# Apply material to the cube\ncube.data.materials.clear()  # Clear any existing materials\ncube.data.materials.append(mat)\nrender_result()\n</pre> fresh_scene()  # colors with nodes  bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create and assign a blue material to the cube mat = bpy.data.materials.new(name=\"BlueMaterial\") mat.use_nodes = True bsdf = mat.node_tree.nodes.get('Principled BSDF') bsdf.inputs['Base Color'].default_value = (0, 0, 1, 1)  # Blue color (R, G, B, A)  # Apply material to the cube cube.data.materials.clear()  # Clear any existing materials cube.data.materials.append(mat) render_result() In\u00a0[28]: Copied! <pre>fresh_scene()\n\nbpy.ops.mesh.primitive_plane_add(size=6, location=(0, 0, 0))\nplane = bpy.context.object\n\nmaterial = bpy.data.materials.new(name=\"ImageMaterial\")\nmaterial.use_nodes = True\nbsdf = material.node_tree.nodes[\"Principled BSDF\"]\n\ntex_image = material.node_tree.nodes.new('ShaderNodeTexImage')\ntex_image.image = bpy.data.images.load(\"cute_dog.jpg\")\n\nmaterial.node_tree.links.new(bsdf.inputs['Base Color'], tex_image.outputs['Color'])\nplane.data.materials.append(material)\n\nrender_result()\n</pre> fresh_scene()  bpy.ops.mesh.primitive_plane_add(size=6, location=(0, 0, 0)) plane = bpy.context.object  material = bpy.data.materials.new(name=\"ImageMaterial\") material.use_nodes = True bsdf = material.node_tree.nodes[\"Principled BSDF\"]  tex_image = material.node_tree.nodes.new('ShaderNodeTexImage') tex_image.image = bpy.data.images.load(\"cute_dog.jpg\")  material.node_tree.links.new(bsdf.inputs['Base Color'], tex_image.outputs['Color']) plane.data.materials.append(material)  render_result() In\u00a0[29]: Copied! <pre>fresh_scene()\n\n# Working with shader nodes is possible, but get's quite involved quite quickly\n\n# Add a cube\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create a new material for the cube\nmaterial = bpy.data.materials.new(name=\"YellowToOrangeGradient\")\nmaterial.use_nodes = True\nnodes = material.node_tree.nodes\n\n# Clear default nodes\nfor node in nodes:\n    nodes.remove(node)\n\n# Add a Gradient Texture\ngradient = nodes.new(type=\"ShaderNodeTexGradient\")\ngradient.gradient_type = \"LINEAR\"\ngradient.location = (0, 0)\n\n# Add a Color Ramp to control the gradient colors\nramp = nodes.new(type=\"ShaderNodeValToRGB\")\nramp.color_ramp.interpolation = \"LINEAR\"\nramp.location = (300, 0)\n\nramp.color_ramp.elements[0].color = (1, 1, 0, 1)  # Yellow (R, G, B, A)\nramp.color_ramp.elements[1].color = (1, 0.3, 0, 1)  # Orange (R, G, B, A)\n\n# Add the Principled BSDF shader\nbsdf = nodes.new(type=\"ShaderNodeBsdfPrincipled\")\nbsdf.location = (600, 0)\n\n# Create the output node\noutput = nodes.new(type=\"ShaderNodeOutputMaterial\")\noutput.location = (900, 0)\n\n# Link the nodes together\nlinks = material.node_tree.links\nlinks.new(gradient.outputs[\"Color\"], ramp.inputs[0])\nlinks.new(ramp.outputs[\"Color\"], bsdf.inputs[\"Base Color\"])\nlinks.new(bsdf.outputs[\"BSDF\"], output.inputs[\"Surface\"])\n\n# Apply the material to the cube\ncube.data.materials.clear()  # Clear any existing materials\ncube.data.materials.append(material)\n\nrender_result()\n</pre> fresh_scene()  # Working with shader nodes is possible, but get's quite involved quite quickly  # Add a cube bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create a new material for the cube material = bpy.data.materials.new(name=\"YellowToOrangeGradient\") material.use_nodes = True nodes = material.node_tree.nodes  # Clear default nodes for node in nodes:     nodes.remove(node)  # Add a Gradient Texture gradient = nodes.new(type=\"ShaderNodeTexGradient\") gradient.gradient_type = \"LINEAR\" gradient.location = (0, 0)  # Add a Color Ramp to control the gradient colors ramp = nodes.new(type=\"ShaderNodeValToRGB\") ramp.color_ramp.interpolation = \"LINEAR\" ramp.location = (300, 0)  ramp.color_ramp.elements[0].color = (1, 1, 0, 1)  # Yellow (R, G, B, A) ramp.color_ramp.elements[1].color = (1, 0.3, 0, 1)  # Orange (R, G, B, A)  # Add the Principled BSDF shader bsdf = nodes.new(type=\"ShaderNodeBsdfPrincipled\") bsdf.location = (600, 0)  # Create the output node output = nodes.new(type=\"ShaderNodeOutputMaterial\") output.location = (900, 0)  # Link the nodes together links = material.node_tree.links links.new(gradient.outputs[\"Color\"], ramp.inputs[0]) links.new(ramp.outputs[\"Color\"], bsdf.inputs[\"Base Color\"]) links.new(bsdf.outputs[\"BSDF\"], output.inputs[\"Surface\"])  # Apply the material to the cube cube.data.materials.clear()  # Clear any existing materials cube.data.materials.append(material)  render_result() In\u00a0[32]: Copied! <pre>fresh_scene()\n\n# Setting up geonodes is possible, but get's quite involved quite quickly\n\n# Add a cube\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Setup geometry nodes\ngeo_nodes = cube.modifiers.new(name=\"GeometryNodes\", type=\"NODES\")\nnode_group = bpy.data.node_groups.new(\"GeometryNodes\", \"GeometryNodeTree\")\ngeo_nodes.node_group = node_group\n\n# Create input/output and transformation nodes\ninNode = node_group.nodes.new(\"NodeGroupInput\")\ninNode.location = (0, 0)\n\ntransformNode = node_group.nodes.new(\"GeometryNodeTransform\")\ntransformNode.location = (300, 0)\ntransformNode.inputs[\"Scale\"].default_value = (3, 2, 1)\n\noutNode = node_group.nodes.new(\"NodeGroupOutput\")\noutNode.location = (600, 0)\n\n# Define geometry input/output sockets\nnode_group.interface.new_socket(name=\"Geometry\", in_out=\"INPUT\", socket_type=\"NodeSocketGeometry\")\nnode_group.interface.new_socket(name=\"Geometry\", in_out=\"OUTPUT\", socket_type=\"NodeSocketGeometry\")\n\n# Link the nodes together\nnode_group.links.new(inNode.outputs[\"Geometry\"], transformNode.inputs[\"Geometry\"])\nnode_group.links.new(transformNode.outputs[\"Geometry\"], outNode.inputs[\"Geometry\"])\n\nrender_result()\n</pre> fresh_scene()  # Setting up geonodes is possible, but get's quite involved quite quickly  # Add a cube bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Setup geometry nodes geo_nodes = cube.modifiers.new(name=\"GeometryNodes\", type=\"NODES\") node_group = bpy.data.node_groups.new(\"GeometryNodes\", \"GeometryNodeTree\") geo_nodes.node_group = node_group  # Create input/output and transformation nodes inNode = node_group.nodes.new(\"NodeGroupInput\") inNode.location = (0, 0)  transformNode = node_group.nodes.new(\"GeometryNodeTransform\") transformNode.location = (300, 0) transformNode.inputs[\"Scale\"].default_value = (3, 2, 1)  outNode = node_group.nodes.new(\"NodeGroupOutput\") outNode.location = (600, 0)  # Define geometry input/output sockets node_group.interface.new_socket(name=\"Geometry\", in_out=\"INPUT\", socket_type=\"NodeSocketGeometry\") node_group.interface.new_socket(name=\"Geometry\", in_out=\"OUTPUT\", socket_type=\"NodeSocketGeometry\")  # Link the nodes together node_group.links.new(inNode.outputs[\"Geometry\"], transformNode.inputs[\"Geometry\"]) node_group.links.new(transformNode.outputs[\"Geometry\"], outNode.inputs[\"Geometry\"])  render_result() In\u00a0[33]: Copied! <pre>bpy.ops.wm.save_as_mainfile(filepath=\"scene.blend\")\n</pre> bpy.ops.wm.save_as_mainfile(filepath=\"scene.blend\") <pre>Info: Total files 1 | Changed 1 | Failed 0\nInfo: Saved \"scene.blend\"\n</pre> Out[33]: <pre>{'FINISHED'}</pre> In\u00a0[34]: Copied! <pre>fresh_scene()\nbpy.ops.wm.open_mainfile(filepath=\"donut.blend\")\n</pre> fresh_scene() bpy.ops.wm.open_mainfile(filepath=\"donut.blend\") Out[34]: <pre>{'FINISHED'}</pre> In\u00a0[35]: Copied! <pre>bpy.context.scene.render.engine = \"BLENDER_WORKBENCH\"\nbpy.context.scene.render.resolution_x = 500\nbpy.context.scene.render.resolution_y = 200\n\nrender_result()\n</pre> bpy.context.scene.render.engine = \"BLENDER_WORKBENCH\" bpy.context.scene.render.resolution_x = 500 bpy.context.scene.render.resolution_y = 200  render_result() In\u00a0[36]: Copied! <pre>bpy.context.scene.render.engine = \"BLENDER_EEVEE_NEXT\"\nrender_result()\n</pre> bpy.context.scene.render.engine = \"BLENDER_EEVEE_NEXT\" render_result() In\u00a0[37]: Copied! <pre>bpy.context.scene.render.engine = \"CYCLES\"\nbpy.context.scene.cycles.samples = 10\nrender_result()\n</pre> bpy.context.scene.render.engine = \"CYCLES\" bpy.context.scene.cycles.samples = 10 render_result() In\u00a0[38]: Copied! <pre># optional: suppress text output (I did not find a better way yet)\nimport sys \nimport os\n\nsys.stdout = open(os.devnull, 'w')\nsys.stderr = open(os.devnull, 'w')\n</pre> # optional: suppress text output (I did not find a better way yet) import sys  import os  sys.stdout = open(os.devnull, 'w') sys.stderr = open(os.devnull, 'w')  In\u00a0[39]: Copied! <pre>bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 0.1\nbpy.context.object.data.update()\nrender_result()\n</pre> bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 0.1 bpy.context.object.data.update() render_result() In\u00a0[40]: Copied! <pre>bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 2\nbpy.context.object.data.update()\nrender_result()\n</pre> bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 2 bpy.context.object.data.update() render_result() In\u00a0[41]: Copied! <pre>bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 10\nbpy.context.object.data.update()\nrender_result()\n</pre> bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 10 bpy.context.object.data.update() render_result() In\u00a0[44]: Copied! <pre>bpy.data.materials[\"Material.001\"].node_tree.nodes[\"Principled BSDF\"].inputs[0].default_value = (0, 0.1, 0, 1)\nrender_result()\n</pre> bpy.data.materials[\"Material.001\"].node_tree.nodes[\"Principled BSDF\"].inputs[0].default_value = (0, 0.1, 0, 1) render_result() In\u00a0[47]: Copied! <pre>bpy.data.materials[\"Material.001\"].node_tree.nodes[\"Principled BSDF\"].inputs[0].default_value = (0, 0, 0.1, 1)\nrender_result()\n</pre> bpy.data.materials[\"Material.001\"].node_tree.nodes[\"Principled BSDF\"].inputs[0].default_value = (0, 0, 0.1, 1) render_result() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"n1a_objects/#adding-objects","title":"Adding Objects\u00b6","text":""},{"location":"n1a_objects/#applying-modifiers","title":"Applying Modifiers\u00b6","text":""},{"location":"n1a_objects/#settings","title":"Settings\u00b6","text":""},{"location":"n1a_objects/#using-colors","title":"Using colors\u00b6","text":""},{"location":"n1a_objects/#setting-up-shaders","title":"Setting Up Shaders\u00b6","text":"<p>Here's an example to generate the following shader tree  It's quite a lot of code, so I would recommend to better set up nodes in the GUI.</p>"},{"location":"n1a_objects/#setting-up-geometry-nodes","title":"Setting up Geometry Nodes\u00b6","text":""},{"location":"n1a_objects/#save-file","title":"Save File\u00b6","text":"<p>You can any time also save your Blender file like this:</p>"},{"location":"n1a_objects/#load-file","title":"Load file\u00b6","text":""},{"location":"n1a_objects/#choose-render-engine","title":"Choose render engine\u00b6","text":""},{"location":"n1a_objects/#manipulate-geometry-nodes","title":"Manipulate geometry nodes\u00b6","text":""},{"location":"n1a_objects/#manipulating-shaders","title":"Manipulating shaders\u00b6","text":""}]}