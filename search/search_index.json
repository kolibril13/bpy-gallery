{"config":{"lang":["en"],"separator":"[\\s\\-_,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bpy Gallery","text":"<p>Welcome to this documentation! \ud83d\udc4b Here, you\u2019ll find a collection of curated examples for using Blender within Python notebooks. If you find these resources helpful, feel free to leave a star \u2b50 on GitHub: https://github.com/kolibril13/bpy-gallery</p>"},{"location":"n0getting_started/","title":"Getting Started","text":""},{"location":"n0getting_started/#how-can-i-use-blender-with-python","title":"How can I use Blender with Python?","text":"<p>Blender has a built-in Python editor, but sometimes it\u2019s useful to work in environments like Jupyter notebooks or VS Code notebooks.</p> <p>There are two ways to use Blender in a notebook:  </p> <ol> <li>Headless Mode: In this mode, you install the Blender Python module bpy from PyPi. The Blender GUI doesn\u2019t open, so you can run it even without a Blender installation.  </li> <li>GUI Mode: This mode uses your installed Blender version, so you can work in the Blender GUI while sending commands from the notebook.</li> </ol>"},{"location":"n0getting_started/#python-package-manger-uv","title":"Python Package manger UV","text":"<p>For the installation, we use the package manager uv.</p> <p>The advantage of <code>uv</code> is that it automatically manages and caches your environment. You can run the same command multiple times without needing virtual environments or handling Python installations manually.</p> <p>Installation macOS: <code>curl -LsSf https://astral.sh/uv/install.sh | sh</code></p> <p>Installation Windows: <code>powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"</code></p>"},{"location":"n0getting_started/#using-headless-mode","title":"Using Headless Mode","text":"<p>To start the notebook, run: <code>uvx --python 3.11 --with bpy==4.2.0 jupyter lab</code></p> <p></p> Code <pre><code>import bpy\nfrom IPython.display import display, Image\nbpy.ops.render.render()\nbpy.data.images[\"Render Result\"].save_render(filepath=\"img.png\")\ndisplay(Image(filename=\"img.png\"))\n</code></pre> <p>Note: The headless mode will only run with Python 3.11 (as of Blender 4.2).</p>"},{"location":"n0getting_started/#using-gui-mode","title":"Using GUI Mode","text":"<p>To set up Blender in GUI mode, we first register the Blender kernel with your notebook environment.</p> <p>On macOS, run: <code>uvx blender_notebook install --blender-exec=\"/Applications/Blender.app/Contents/MacOS/Blender\"</code></p> <p><code>uvx --python 3.11 jupyter lab</code></p> <p>(under the hood, this is using blender_notebook)</p> <p>On Windows, run: <code>uvx blender_notebook install --blender-exec=\"C:\\Program Files\\Blender Foundation\\Blender 4.2\\blender.exe\"</code></p> <p><code>uvx --python 3.11 jupyter lab</code> (Windows installation is not yet tested)</p> <p>Once set up, you can select the Blender kernel in Jupyter Lab.</p> <p>Select the Blender kernel in JupyterLab like this:</p> <p>Note: GUI mode also works with other notebook environments, such as VS Code notebooks and Satyrn notebooks.</p> <p>Select the Blender kernel in VS Code like this:</p>"},{"location":"n1objects/","title":"Adding Objects","text":"In\u00a0[1]: Copied! <pre>import bpy\nbpy.app.version_string # current blender version\n</pre> import bpy bpy.app.version_string # current blender version Out[1]: <pre>'4.3.2'</pre> In\u00a0[2]: Copied! <pre>from pathlib import Path\nfrom IPython.display import display, Image\nfrom math import radians\n\n\ndef fresh_scene(keep_cube=False):\n    # Deselect all objects\n    bpy.ops.object.select_all(action='DESELECT')\n    \n    # Select all objects except cameras and optionally the default cube\n    for obj in bpy.context.scene.objects:\n        if obj.type == 'CAMERA':\n            obj.select_set(False)\n        elif obj.name == 'Cube' and keep_cube:\n            obj.select_set(False)\n        else:\n            obj.select_set(True)\n    \n    # Delete selected objects\n    bpy.ops.object.delete()\n    \n    # Add a light source\n    bpy.ops.object.light_add(type='SUN')\n    sun = bpy.context.active_object\n\n    sun.location = (0, 0, 0)\n    sun.rotation_euler = (radians(204), radians(-133), radians(-67))\n    sun.data.energy = 5  \n\ndef render_result():\n    # Render the scene and save the result to the desktop\n    path = Path.home() / 'Downloads'\n    output_path = str(path / 'img.png')\n    bpy.ops.render.render()\n    bpy.data.images['Render Result'].save_render(filepath=output_path)\n    \n    # Display the saved image\n    display(Image(filename=output_path))\n\n# Set render resolution\nbpy.context.scene.render.resolution_x = 500\nbpy.context.scene.render.resolution_y = 200\n</pre> from pathlib import Path from IPython.display import display, Image from math import radians   def fresh_scene(keep_cube=False):     # Deselect all objects     bpy.ops.object.select_all(action='DESELECT')          # Select all objects except cameras and optionally the default cube     for obj in bpy.context.scene.objects:         if obj.type == 'CAMERA':             obj.select_set(False)         elif obj.name == 'Cube' and keep_cube:             obj.select_set(False)         else:             obj.select_set(True)          # Delete selected objects     bpy.ops.object.delete()          # Add a light source     bpy.ops.object.light_add(type='SUN')     sun = bpy.context.active_object      sun.location = (0, 0, 0)     sun.rotation_euler = (radians(204), radians(-133), radians(-67))     sun.data.energy = 5    def render_result():     # Render the scene and save the result to the desktop     path = Path.home() / 'Downloads'     output_path = str(path / 'img.png')     bpy.ops.render.render()     bpy.data.images['Render Result'].save_render(filepath=output_path)          # Display the saved image     display(Image(filename=output_path))  # Set render resolution bpy.context.scene.render.resolution_x = 500 bpy.context.scene.render.resolution_y = 200 In\u00a0[3]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_monkey_add(size=2.5, location=(0, 0, 0))\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_monkey_add(size=2.5, location=(0, 0, 0)) render_result() In\u00a0[4]: Copied! <pre>fresh_scene()\n#bpy.ops.object.gpencil_add(location=(0, 0, 0), type='STROKE') # Blender 4.2\nbpy.ops.object.grease_pencil_add(location=(0, 0, 0), type=\"STROKE\") # Blender 4.3.1\ngpencil_object = bpy.context.active_object\ngpencil_object.scale = (3, 3, 3)\nrender_result()\n</pre> fresh_scene() #bpy.ops.object.gpencil_add(location=(0, 0, 0), type='STROKE') # Blender 4.2 bpy.ops.object.grease_pencil_add(location=(0, 0, 0), type=\"STROKE\") # Blender 4.3.1 gpencil_object = bpy.context.active_object gpencil_object.scale = (3, 3, 3) render_result() In\u00a0[5]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, location=(0, 0, 0))  render_result() In\u00a0[6]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cone_add(radius1=1, depth=2, location=(0, 0, 0))  \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cone_add(radius1=1, depth=2, location=(0, 0, 0))   render_result() In\u00a0[7]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(0, 0, 0))  render_result() In\u00a0[8]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_torus_add(major_radius=2, minor_radius=0.3, location=(0,0, 0))\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_torus_add(major_radius=2, minor_radius=0.3, location=(0,0, 0)) render_result() In\u00a0[9]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_ico_sphere_add(radius=1, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_ico_sphere_add(radius=1, location=(0, 0, 0))  render_result() In\u00a0[10]: Copied! <pre>fresh_scene()\nbpy.ops.object.text_add(location=(-4, 0, 0))\ntext = bpy.context.active_object\ntext.data.body = \"Hello \ud83d\ude04\"\ntext.scale = (2, 2, 2)\nrender_result()\n</pre> fresh_scene() bpy.ops.object.text_add(location=(-4, 0, 0)) text = bpy.context.active_object text.data.body = \"Hello \ud83d\ude04\" text.scale = (2, 2, 2) render_result() In\u00a0[11]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_plane_add(size=3, location=(0, 0, 0))  \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_plane_add(size=3, location=(0, 0, 0))   render_result() In\u00a0[12]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_circle_add(radius=2.5, location=(0, 0, 0), fill_type='NGON')\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_circle_add(radius=2.5, location=(0, 0, 0), fill_type='NGON') render_result() In\u00a0[13]: Copied! <pre>fresh_scene()\nbpy.ops.object.empty_add(type='PLAIN_AXES', location=(4, 0, 0)) # (This is not shown in the image, but it is there :) )\nrender_result()\n</pre> fresh_scene() bpy.ops.object.empty_add(type='PLAIN_AXES', location=(4, 0, 0)) # (This is not shown in the image, but it is there :) ) render_result() In\u00a0[14]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))  render_result() In\u00a0[15]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) \nlight = bpy.data.objects.new(\"Light\", bpy.data.lights.new(\"Light\", 'POINT'))\nlight.location = (3, 0, 2)\nlight.data.energy = 8000\nbpy.context.collection.objects.link(light)\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))  light = bpy.data.objects.new(\"Light\", bpy.data.lights.new(\"Light\", 'POINT')) light.location = (3, 0, 2) light.data.energy = 8000 bpy.context.collection.objects.link(light) render_result() In\u00a0[16]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) \ncube = bpy.context.active_object\nbevel_modifier = cube.modifiers.new(name=\"Bevel\", type='BEVEL')\nbevel_modifier.width = 0.4  # Adjust the bevel width\nbevel_modifier.segments = 5  # Number of segments for a smoother bevel\n\n# Optionally apply the modifier if needed (not necessary for visualization)\n# bpy.ops.object.modifier_apply(modifier=\"Bevel\")\n\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))  cube = bpy.context.active_object bevel_modifier = cube.modifiers.new(name=\"Bevel\", type='BEVEL') bevel_modifier.width = 0.4  # Adjust the bevel width bevel_modifier.segments = 5  # Number of segments for a smoother bevel  # Optionally apply the modifier if needed (not necessary for visualization) # bpy.ops.object.modifier_apply(modifier=\"Bevel\")  render_result() In\u00a0[17]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create the subdivision surface modifier and change it to 'SIMPLE'\nsubsurf_modifier = cube.modifiers.new(name=\"Subdivision\", type='SUBSURF')\nsubsurf_modifier.subdivision_type = 'SIMPLE'  # Change to 'SIMPLE' instead of 'CATMULL_CLARK'\nsubsurf_modifier.levels = 4  # Viewport subdivision level\nsubsurf_modifier.render_levels = 4  # Render subdivision level\n\ndisplace_modifier = cube.modifiers.new(name=\"Displace\", type='DISPLACE')\ndisplace_modifier.strength = 0.5  # Adjust the displacement strength\n\ntexture = bpy.data.textures.new(\"DisplaceTexture\", type='CLOUDS')\ntexture.noise_scale = 1  # Reduce the noise scale to make it more detailed\ndisplace_modifier.texture = texture  # Assign the texture to the modifier\n\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create the subdivision surface modifier and change it to 'SIMPLE' subsurf_modifier = cube.modifiers.new(name=\"Subdivision\", type='SUBSURF') subsurf_modifier.subdivision_type = 'SIMPLE'  # Change to 'SIMPLE' instead of 'CATMULL_CLARK' subsurf_modifier.levels = 4  # Viewport subdivision level subsurf_modifier.render_levels = 4  # Render subdivision level  displace_modifier = cube.modifiers.new(name=\"Displace\", type='DISPLACE') displace_modifier.strength = 0.5  # Adjust the displacement strength  texture = bpy.data.textures.new(\"DisplaceTexture\", type='CLOUDS') texture.noise_scale = 1  # Reduce the noise scale to make it more detailed displace_modifier.texture = texture  # Assign the texture to the modifier  render_result() In\u00a0[18]: Copied! <pre># current blender version\nbpy.app.version_string\n</pre> # current blender version bpy.app.version_string Out[18]: <pre>'4.3.2'</pre> In\u00a0[19]: Copied! <pre># current blender version\nbpy.context.scene.render.engine\n</pre> # current blender version bpy.context.scene.render.engine Out[19]: <pre>'BLENDER_EEVEE_NEXT'</pre> In\u00a0[20]: Copied! <pre>bpy.context.scene.render.resolution_x, bpy.context.scene.render.resolution_y\n</pre> bpy.context.scene.render.resolution_x, bpy.context.scene.render.resolution_y Out[20]: <pre>(500, 200)</pre> In\u00a0[21]: Copied! <pre>bpy.context.scene.name\n</pre> bpy.context.scene.name Out[21]: <pre>'Scene'</pre> In\u00a0[22]: Copied! <pre>bpy.context.active_object.name\n</pre> bpy.context.active_object.name Out[22]: <pre>'Cube'</pre> In\u00a0[23]: Copied! <pre>bpy.context.active_object.location\n</pre> bpy.context.active_object.location Out[23]: <pre>Vector((0.0, 0.0, 0.0))</pre> In\u00a0[24]: Copied! <pre>bpy.context.collection.objects.keys()\n</pre> bpy.context.collection.objects.keys() Out[24]: <pre>['Camera', 'Sun', 'Cube']</pre> In\u00a0[25]: Copied! <pre>bpy.context.collection.objects.values()\n</pre> bpy.context.collection.objects.values() Out[25]: <pre>[bpy.data.objects['Camera'], bpy.data.objects['Sun'], bpy.data.objects['Cube']]</pre> In\u00a0[26]: Copied! <pre>fresh_scene()\n\n# Add a cube\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create and assign a green material to the cube without using nodes\nmat = bpy.data.materials.new(name=\"GreenMaterial\")\nmat.diffuse_color = (0, 1, 0, 1)  # Green color (R, G, B, A)\n\n# Apply material to the cube\ncube.data.materials.clear()  # Clear any existing materials\ncube.data.materials.append(mat)\n\nrender_result()\n</pre> fresh_scene()  # Add a cube bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create and assign a green material to the cube without using nodes mat = bpy.data.materials.new(name=\"GreenMaterial\") mat.diffuse_color = (0, 1, 0, 1)  # Green color (R, G, B, A)  # Apply material to the cube cube.data.materials.clear()  # Clear any existing materials cube.data.materials.append(mat)  render_result() In\u00a0[27]: Copied! <pre>fresh_scene()\n\n# colors with nodes\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create and assign a blue material to the cube\nmat = bpy.data.materials.new(name=\"BlueMaterial\")\nmat.use_nodes = True\nbsdf = mat.node_tree.nodes.get('Principled BSDF')\nbsdf.inputs['Base Color'].default_value = (0, 0, 1, 1)  # Blue color (R, G, B, A)\n\n# Apply material to the cube\ncube.data.materials.clear()  # Clear any existing materials\ncube.data.materials.append(mat)\nrender_result()\n</pre> fresh_scene()  # colors with nodes  bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create and assign a blue material to the cube mat = bpy.data.materials.new(name=\"BlueMaterial\") mat.use_nodes = True bsdf = mat.node_tree.nodes.get('Principled BSDF') bsdf.inputs['Base Color'].default_value = (0, 0, 1, 1)  # Blue color (R, G, B, A)  # Apply material to the cube cube.data.materials.clear()  # Clear any existing materials cube.data.materials.append(mat) render_result() In\u00a0[28]: Copied! <pre>fresh_scene()\n\nbpy.ops.mesh.primitive_plane_add(size=6, location=(0, 0, 0))\n# plane = bpy.context.object # only blender 4.1\nplane = bpy.context.active_object #blender 4.3\n\nmaterial = bpy.data.materials.new(name=\"ImageMaterial\")\nmaterial.use_nodes = True\nbsdf = material.node_tree.nodes[\"Principled BSDF\"]\n\ntex_image = material.node_tree.nodes.new('ShaderNodeTexImage')\n\npath = Path.home() / \"projects/bpy-gallery/docs/cute_dog.jpg\" \n\ntex_image.image = bpy.data.images.load(str(path))\n\nmaterial.node_tree.links.new(bsdf.inputs['Base Color'], tex_image.outputs['Color'])\nplane.data.materials.append(material)\n\nrender_result()\n</pre> fresh_scene()  bpy.ops.mesh.primitive_plane_add(size=6, location=(0, 0, 0)) # plane = bpy.context.object # only blender 4.1 plane = bpy.context.active_object #blender 4.3  material = bpy.data.materials.new(name=\"ImageMaterial\") material.use_nodes = True bsdf = material.node_tree.nodes[\"Principled BSDF\"]  tex_image = material.node_tree.nodes.new('ShaderNodeTexImage')  path = Path.home() / \"projects/bpy-gallery/docs/cute_dog.jpg\"   tex_image.image = bpy.data.images.load(str(path))  material.node_tree.links.new(bsdf.inputs['Base Color'], tex_image.outputs['Color']) plane.data.materials.append(material)  render_result() In\u00a0[29]: Copied! <pre>fresh_scene()\n\n# Working with shader nodes is possible, but get's quite involved quite quickly\n\n# Add a cube\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create a new material for the cube\nmaterial = bpy.data.materials.new(name=\"YellowToOrangeGradient\")\nmaterial.use_nodes = True\nnodes = material.node_tree.nodes\n\n# Clear default nodes\nfor node in nodes:\n    nodes.remove(node)\n\n# Add a Gradient Texture\ngradient = nodes.new(type=\"ShaderNodeTexGradient\")\ngradient.gradient_type = \"LINEAR\"\ngradient.location = (0, 0)\n\n# Add a Color Ramp to control the gradient colors\nramp = nodes.new(type=\"ShaderNodeValToRGB\")\nramp.color_ramp.interpolation = \"LINEAR\"\nramp.location = (300, 0)\n\nramp.color_ramp.elements[0].color = (1, 1, 0, 1)  # Yellow (R, G, B, A)\nramp.color_ramp.elements[1].color = (1, 0.3, 0, 1)  # Orange (R, G, B, A)\n\n# Add the Principled BSDF shader\nbsdf = nodes.new(type=\"ShaderNodeBsdfPrincipled\")\nbsdf.location = (600, 0)\n\n# Create the output node\noutput = nodes.new(type=\"ShaderNodeOutputMaterial\")\noutput.location = (900, 0)\n\n# Link the nodes together\nlinks = material.node_tree.links\nlinks.new(gradient.outputs[\"Color\"], ramp.inputs[0])\nlinks.new(ramp.outputs[\"Color\"], bsdf.inputs[\"Base Color\"])\nlinks.new(bsdf.outputs[\"BSDF\"], output.inputs[\"Surface\"])\n\n# Apply the material to the cube\ncube.data.materials.clear()  # Clear any existing materials\ncube.data.materials.append(material)\n\nrender_result()\n</pre> fresh_scene()  # Working with shader nodes is possible, but get's quite involved quite quickly  # Add a cube bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create a new material for the cube material = bpy.data.materials.new(name=\"YellowToOrangeGradient\") material.use_nodes = True nodes = material.node_tree.nodes  # Clear default nodes for node in nodes:     nodes.remove(node)  # Add a Gradient Texture gradient = nodes.new(type=\"ShaderNodeTexGradient\") gradient.gradient_type = \"LINEAR\" gradient.location = (0, 0)  # Add a Color Ramp to control the gradient colors ramp = nodes.new(type=\"ShaderNodeValToRGB\") ramp.color_ramp.interpolation = \"LINEAR\" ramp.location = (300, 0)  ramp.color_ramp.elements[0].color = (1, 1, 0, 1)  # Yellow (R, G, B, A) ramp.color_ramp.elements[1].color = (1, 0.3, 0, 1)  # Orange (R, G, B, A)  # Add the Principled BSDF shader bsdf = nodes.new(type=\"ShaderNodeBsdfPrincipled\") bsdf.location = (600, 0)  # Create the output node output = nodes.new(type=\"ShaderNodeOutputMaterial\") output.location = (900, 0)  # Link the nodes together links = material.node_tree.links links.new(gradient.outputs[\"Color\"], ramp.inputs[0]) links.new(ramp.outputs[\"Color\"], bsdf.inputs[\"Base Color\"]) links.new(bsdf.outputs[\"BSDF\"], output.inputs[\"Surface\"])  # Apply the material to the cube cube.data.materials.clear()  # Clear any existing materials cube.data.materials.append(material)  render_result() In\u00a0[30]: Copied! <pre>fresh_scene()\n\n# Setting up geonodes is possible, but get's quite involved quite quickly\n\n# Add a cube\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Setup geometry nodes\ngeo_nodes = cube.modifiers.new(name=\"GeometryNodes\", type=\"NODES\")\nnode_group = bpy.data.node_groups.new(\"GeometryNodes\", \"GeometryNodeTree\")\ngeo_nodes.node_group = node_group\n\n# Create input/output and transformation nodes\ninNode = node_group.nodes.new(\"NodeGroupInput\")\ninNode.location = (0, 0)\n\ntransformNode = node_group.nodes.new(\"GeometryNodeTransform\")\ntransformNode.location = (300, 0)\ntransformNode.inputs[\"Scale\"].default_value = (3, 2, 1)\n\noutNode = node_group.nodes.new(\"NodeGroupOutput\")\noutNode.location = (600, 0)\n\n# Define geometry input/output sockets\nnode_group.interface.new_socket(name=\"Geometry\", in_out=\"INPUT\", socket_type=\"NodeSocketGeometry\")\nnode_group.interface.new_socket(name=\"Geometry\", in_out=\"OUTPUT\", socket_type=\"NodeSocketGeometry\")\n\n# Link the nodes together\nnode_group.links.new(inNode.outputs[\"Geometry\"], transformNode.inputs[\"Geometry\"])\nnode_group.links.new(transformNode.outputs[\"Geometry\"], outNode.inputs[\"Geometry\"])\n\nrender_result()\n</pre> fresh_scene()  # Setting up geonodes is possible, but get's quite involved quite quickly  # Add a cube bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Setup geometry nodes geo_nodes = cube.modifiers.new(name=\"GeometryNodes\", type=\"NODES\") node_group = bpy.data.node_groups.new(\"GeometryNodes\", \"GeometryNodeTree\") geo_nodes.node_group = node_group  # Create input/output and transformation nodes inNode = node_group.nodes.new(\"NodeGroupInput\") inNode.location = (0, 0)  transformNode = node_group.nodes.new(\"GeometryNodeTransform\") transformNode.location = (300, 0) transformNode.inputs[\"Scale\"].default_value = (3, 2, 1)  outNode = node_group.nodes.new(\"NodeGroupOutput\") outNode.location = (600, 0)  # Define geometry input/output sockets node_group.interface.new_socket(name=\"Geometry\", in_out=\"INPUT\", socket_type=\"NodeSocketGeometry\") node_group.interface.new_socket(name=\"Geometry\", in_out=\"OUTPUT\", socket_type=\"NodeSocketGeometry\")  # Link the nodes together node_group.links.new(inNode.outputs[\"Geometry\"], transformNode.inputs[\"Geometry\"]) node_group.links.new(transformNode.outputs[\"Geometry\"], outNode.inputs[\"Geometry\"])  render_result() In\u00a0[31]: Copied! <pre>path = str(Path.home() / 'Downloads/temp_scene.blend')\nbpy.ops.wm.save_as_mainfile(filepath=path) \n</pre> path = str(Path.home() / 'Downloads/temp_scene.blend') bpy.ops.wm.save_as_mainfile(filepath=path)  <pre>Info: Saved \"temp_scene.blend\"\n</pre> Out[31]: <pre>{'FINISHED'}</pre> In\u00a0[32]: Copied! <pre>fresh_scene()\n#bpy.ops.wm.open_mainfile(filepath=\"donut.blend\") # this will loose kernel connection\n\npath = Path.home() / \"projects/bpy-gallery/docs/donut.blend\" \nfilepath= str(path)\n\n# Import all objects from the .blend file\nwith bpy.data.libraries.load(filepath, link=False) as (data_from, data_to):\n    data_to.objects = data_from.objects\n\n# Link imported objects to the current scene\nfor obj in data_to.objects:\n    if obj is not None:\n        bpy.context.collection.objects.link(obj)\n</pre> fresh_scene() #bpy.ops.wm.open_mainfile(filepath=\"donut.blend\") # this will loose kernel connection  path = Path.home() / \"projects/bpy-gallery/docs/donut.blend\"  filepath= str(path)  # Import all objects from the .blend file with bpy.data.libraries.load(filepath, link=False) as (data_from, data_to):     data_to.objects = data_from.objects  # Link imported objects to the current scene for obj in data_to.objects:     if obj is not None:         bpy.context.collection.objects.link(obj) In\u00a0[33]: Copied! <pre>import bpy\n\n# Name of the imported camera\ncamera_name = \"Camera.001\"\n\n# Get the imported camera object\ncamera_object = bpy.data.objects.get(camera_name)\n\nif camera_object:\n    # Set the camera as the active camera in the scene\n    bpy.context.scene.camera = camera_object\n    print(f\"{camera_name} is now the main camera.\")\nelse:\n    print(f\"Camera '{camera_name}' not found.\")\n</pre> import bpy  # Name of the imported camera camera_name = \"Camera.001\"  # Get the imported camera object camera_object = bpy.data.objects.get(camera_name)  if camera_object:     # Set the camera as the active camera in the scene     bpy.context.scene.camera = camera_object     print(f\"{camera_name} is now the main camera.\") else:     print(f\"Camera '{camera_name}' not found.\")  <pre>Camera.001 is now the main camera.\n</pre> In\u00a0[34]: Copied! <pre>bpy.context.scene.render.engine = \"BLENDER_WORKBENCH\" \n\nbpy.context.scene.render.resolution_x = 500\nbpy.context.scene.render.resolution_y = 200\n\nrender_result()\n</pre> bpy.context.scene.render.engine = \"BLENDER_WORKBENCH\"   bpy.context.scene.render.resolution_x = 500 bpy.context.scene.render.resolution_y = 200  render_result() In\u00a0[35]: Copied! <pre>bpy.context.scene.render.engine = \"BLENDER_EEVEE_NEXT\"\nrender_result()\n</pre> bpy.context.scene.render.engine = \"BLENDER_EEVEE_NEXT\" render_result() In\u00a0[36]: Copied! <pre>bpy.context.scene.render.engine = \"CYCLES\"\nbpy.context.scene.cycles.samples = 10\nrender_result()\n</pre> bpy.context.scene.render.engine = \"CYCLES\" bpy.context.scene.cycles.samples = 10 render_result() In\u00a0[37]: Copied! <pre>bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 0.1\nrender_result()\n</pre> bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 0.1 render_result() In\u00a0[38]: Copied! <pre>bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 2\nrender_result()\n</pre> bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 2 render_result() In\u00a0[39]: Copied! <pre>bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 10\nrender_result()\n</pre> bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 10 render_result() <pre>[I 2025-01-17 11:00:13.994 ServerApp] Saving file at /n1objects.ipynb\n</pre>"},{"location":"n1objects/#adding-objects","title":"Adding Objects\u00b6","text":""},{"location":"n1objects/#applying-modifiers","title":"Applying Modifiers\u00b6","text":""},{"location":"n1objects/#settings","title":"Settings\u00b6","text":""},{"location":"n1objects/#using-colors","title":"Using colors\u00b6","text":""},{"location":"n1objects/#setting-up-shaders","title":"Setting Up Shaders\u00b6","text":"<p>Here's an example to generate the following shader tree  It's quite a lot of code, so I would recommend to better set up nodes in the GUI.</p>"},{"location":"n1objects/#setting-up-geometry-nodes","title":"Setting up Geometry Nodes\u00b6","text":""},{"location":"n1objects/#save-file","title":"Save File\u00b6","text":"<p>You can any time also save your Blender file like this:</p>"},{"location":"n1objects/#load-file","title":"Load file\u00b6","text":""},{"location":"n1objects/#choose-render-engine","title":"Choose render engine\u00b6","text":""},{"location":"n1objects/#manipulate-geometry-nodes","title":"Manipulate geometry nodes\u00b6","text":""},{"location":"n2data_simple/","title":"Simple data","text":"In\u00a0[58]: Copied! <pre>import bpy\nfrom IPython.display import display, Image\n\ndef fresh_scene(keep_cube=False):\n    # Deselect all objects\n    bpy.ops.object.select_all(action='DESELECT')\n    \n    # Select all objects except cameras and optionally the default cube\n    for obj in bpy.context.scene.objects:\n        if obj.type == 'CAMERA':\n            obj.select_set(False)\n        elif obj.name == 'Cube' and keep_cube:\n            obj.select_set(False)\n        else:\n            obj.select_set(True)\n    \n    bpy.ops.object.delete()\n    \n    # Add light\n    bpy.ops.object.light_add(type='SUN')\n    sun = bpy.context.active_object\n\n    sun.location = (0, 0, 0)\n    from math import radians\n    sun.rotation_euler = (radians(204), radians(-133), radians(-67))\n    sun.data.energy = 5  \n\n\ndef render_result():\n    bpy.ops.render.render()\n    bpy.data.images['Render Result'].save_render(filepath=\"img.png\")\n    display(Image(filename=\"img.png\"))\n\nbpy.context.scene.render.resolution_x = 500\nbpy.context.scene.render.resolution_y = 200\n</pre> import bpy from IPython.display import display, Image  def fresh_scene(keep_cube=False):     # Deselect all objects     bpy.ops.object.select_all(action='DESELECT')          # Select all objects except cameras and optionally the default cube     for obj in bpy.context.scene.objects:         if obj.type == 'CAMERA':             obj.select_set(False)         elif obj.name == 'Cube' and keep_cube:             obj.select_set(False)         else:             obj.select_set(True)          bpy.ops.object.delete()          # Add light     bpy.ops.object.light_add(type='SUN')     sun = bpy.context.active_object      sun.location = (0, 0, 0)     from math import radians     sun.rotation_euler = (radians(204), radians(-133), radians(-67))     sun.data.energy = 5     def render_result():     bpy.ops.render.render()     bpy.data.images['Render Result'].save_render(filepath=\"img.png\")     display(Image(filename=\"img.png\"))  bpy.context.scene.render.resolution_x = 500 bpy.context.scene.render.resolution_y = 200 In\u00a0[59]: Copied! <pre>import bpy\nimport subprocess\nimport sys\n\n# Path to Blender's Python executable\npython_executable = sys.executable\ntry:\n    subprocess.check_call([python_executable, \"-m\", \"pip\", \"install\", \"polars\"])\n    subprocess.check_call([python_executable, \"-m\", \"pip\", \"install\", \"matplotlib\"])\n    subprocess.check_call([python_executable, \"-m\", \"pip\", \"install\", \"databpy\"])\n\n    print(\"Done\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n</pre> import bpy import subprocess import sys  # Path to Blender's Python executable python_executable = sys.executable try:     subprocess.check_call([python_executable, \"-m\", \"pip\", \"install\", \"polars\"])     subprocess.check_call([python_executable, \"-m\", \"pip\", \"install\", \"matplotlib\"])     subprocess.check_call([python_executable, \"-m\", \"pip\", \"install\", \"databpy\"])      print(\"Done\") except Exception as e:     print(f\"An error occurred: {e}\") <pre>Requirement already satisfied: polars in /Applications/Blender.app/Contents/Resources/4.3/python/lib/python3.11/site-packages (1.19.0)\n</pre> <pre>\n[notice] A new release of pip is available: 24.0 -&gt; 24.3.1\n[notice] To update, run: /Applications/Blender.app/Contents/Resources/4.3/python/bin/python3.11 -m pip install --upgrade pip\n</pre> <pre>Requirement already satisfied: matplotlib in /Applications/Blender.app/Contents/Resources/4.3/python/lib/python3.11/site-packages (3.10.0)\nRequirement already satisfied: contourpy&gt;=1.0.1 in /Applications/Blender.app/Contents/Resources/4.3/python/lib/python3.11/site-packages (from matplotlib) (1.3.1)\nRequirement already satisfied: cycler&gt;=0.10 in /Applications/Blender.app/Contents/Resources/4.3/python/lib/python3.11/site-packages (from matplotlib) (0.12.1)\nRequirement already satisfied: fonttools&gt;=4.22.0 in /Applications/Blender.app/Contents/Resources/4.3/python/lib/python3.11/site-packages (from matplotlib) (4.55.3)\nRequirement already satisfied: kiwisolver&gt;=1.3.1 in /Applications/Blender.app/Contents/Resources/4.3/python/lib/python3.11/site-packages (from matplotlib) (1.4.8)\nRequirement already satisfied: numpy&gt;=1.23 in /Applications/Blender.app/Contents/Resources/4.3/python/lib/python3.11/site-packages (from matplotlib) (1.24.3)\nRequirement already satisfied: packaging&gt;=20.0 in /Users/jan-hendrik/.local/lib/python3.11/site-packages (from matplotlib) (24.1)\nRequirement already satisfied: pillow&gt;=8 in /Applications/Blender.app/Contents/Resources/4.3/python/lib/python3.11/site-packages (from matplotlib) (11.1.0)\nRequirement already satisfied: pyparsing&gt;=2.3.1 in /Applications/Blender.app/Contents/Resources/4.3/python/lib/python3.11/site-packages (from matplotlib) (3.2.1)\nRequirement already satisfied: python-dateutil&gt;=2.7 in /Users/jan-hendrik/.local/lib/python3.11/site-packages (from matplotlib) (2.9.0.post0)\nRequirement already satisfied: six&gt;=1.5 in /Applications/Blender.app/Contents/Resources/4.3/python/lib/python3.11/site-packages (from python-dateutil&gt;=2.7-&gt;matplotlib) (1.17.0)\n</pre> <pre>\n[notice] A new release of pip is available: 24.0 -&gt; 24.3.1\n[notice] To update, run: /Applications/Blender.app/Contents/Resources/4.3/python/bin/python3.11 -m pip install --upgrade pip\n</pre> <pre>Requirement already satisfied: databpy in /Applications/Blender.app/Contents/Resources/4.3/python/lib/python3.11/site-packages (0.0.8)\nRequirement already satisfied: numpy&lt;2.0,&gt;=1.24.0 in /Applications/Blender.app/Contents/Resources/4.3/python/lib/python3.11/site-packages (from databpy) (1.24.3)\nDone\n</pre> <pre>\n[notice] A new release of pip is available: 24.0 -&gt; 24.3.1\n[notice] To update, run: /Applications/Blender.app/Contents/Resources/4.3/python/bin/python3.11 -m pip install --upgrade pip\n</pre> In\u00a0[60]: Copied! <pre>import polars as pl\nurl = 'https://raw.githubusercontent.com/kolibril13/ipydrop/refs/heads/main/dino.csv'\ndf1 = pl.read_csv(url)\nlength_data = len(df1)\nprint(f\"Loaded {length_data} rows\")\ndf1.head()\n</pre> import polars as pl url = 'https://raw.githubusercontent.com/kolibril13/ipydrop/refs/heads/main/dino.csv' df1 = pl.read_csv(url) length_data = len(df1) print(f\"Loaded {length_data} rows\") df1.head() <pre>Loaded 142 rows\n</pre> Out[60]: shape: (5, 2)xyf64f6455.384697.179551.538596.025646.153894.487242.820591.410340.769288.3333 In\u00a0[61]: Copied! <pre>import matplotlib.pyplot as plt\nplt.style.use('_mpl-gallery')\n</pre> import matplotlib.pyplot as plt plt.style.use('_mpl-gallery') In\u00a0[62]: Copied! <pre># Extract x and y from the DataFrame\nx_values1 = df1['x'] / 10 \ny_values1 = df1['y'] / 10 * 0.8\n\n# Create the scatter plot using plt.scatter\nplt.axis('equal');\nplt.scatter(x_values1, y_values1);\n</pre> # Extract x and y from the DataFrame x_values1 = df1['x'] / 10  y_values1 = df1['y'] / 10 * 0.8  # Create the scatter plot using plt.scatter plt.axis('equal'); plt.scatter(x_values1, y_values1); In\u00a0[63]: Copied! <pre>def camera_from_above():\n    camera = bpy.context.scene.camera\n    camera.location = (6, 4, 10)  # Position above the XY plane\n    camera.rotation_euler = (0, 0, 0)  # Rotate to look at XY plane\n    # Set the camera to orthographic mode\n    camera.data.type = 'ORTHO'\n    # Set the orthographic scale to 12\n    camera.data.ortho_scale = 9\n\n    bpy.context.scene.render.resolution_x = 300\n    bpy.context.scene.render.resolution_y = 300\n</pre> def camera_from_above():     camera = bpy.context.scene.camera     camera.location = (6, 4, 10)  # Position above the XY plane     camera.rotation_euler = (0, 0, 0)  # Rotate to look at XY plane     # Set the camera to orthographic mode     camera.data.type = 'ORTHO'     # Set the orthographic scale to 12     camera.data.ortho_scale = 9      bpy.context.scene.render.resolution_x = 300     bpy.context.scene.render.resolution_y = 300 In\u00a0[64]: Copied! <pre>fresh_scene()\n\nfor (x, y) in zip(x_values1,y_values1):    \n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.2, location=(x, y, 0))\n\ncamera_from_above()\nrender_result()\n</pre> fresh_scene()  for (x, y) in zip(x_values1,y_values1):         bpy.ops.mesh.primitive_uv_sphere_add(radius=0.2, location=(x, y, 0))  camera_from_above() render_result() In\u00a0[65]: Copied! <pre>fresh_scene()\n\nmat = bpy.data.materials.new(name=\"GreenMaterial\")\nmat.diffuse_color = (0, 0, 1, 1)  # Green color (R, G, B, A)\n\nfor (x, y) in zip(x_values1,y_values1):    \n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.2, location=(x, y, 0))\n    bpy.context.active_object.data.materials.append(mat)\n\nbpy.context.scene.render.resolution_x = 300\nbpy.context.scene.render.resolution_y = 300\n\n# Add a white plane behind the spheres\nbpy.ops.mesh.primitive_plane_add(size=20, location=(5, 5, 0))  \nplane = bpy.context.active_object\n\n# Create a white material and assign it to the plane\nwhite_mat = bpy.data.materials.new(name=\"WhiteMaterial\")\nwhite_mat.diffuse_color = (1, 1, 1, 1)  # White color (R, G, B, A)\nplane.data.materials.append(white_mat)\n\nrender_result()\n</pre> fresh_scene()  mat = bpy.data.materials.new(name=\"GreenMaterial\") mat.diffuse_color = (0, 0, 1, 1)  # Green color (R, G, B, A)  for (x, y) in zip(x_values1,y_values1):         bpy.ops.mesh.primitive_uv_sphere_add(radius=0.2, location=(x, y, 0))     bpy.context.active_object.data.materials.append(mat)  bpy.context.scene.render.resolution_x = 300 bpy.context.scene.render.resolution_y = 300  # Add a white plane behind the spheres bpy.ops.mesh.primitive_plane_add(size=20, location=(5, 5, 0))   plane = bpy.context.active_object  # Create a white material and assign it to the plane white_mat = bpy.data.materials.new(name=\"WhiteMaterial\") white_mat.diffuse_color = (1, 1, 1, 1)  # White color (R, G, B, A) plane.data.materials.append(white_mat)  render_result() <p>this works, but it's very limited! E.g.</p> <ul> <li>not possible to scale individual spheres.</li> <li>not possible to use geometry nodes with this object.</li> </ul> <p>Can we maybe add this geometry nodes setup?</p> In\u00a0[66]: Copied! <pre># option 1: Load the node group to the current blend scene\n#TODO Make this it's own utility tool\nimport bpy\n# Path to the blend file\nblend_file_path = \"docs/cube_gn_position.blend\"\nnode_group_name = \"gn_place_spheres\"\n\n# Load only the node group from the blend file\nwith bpy.data.libraries.load(blend_file_path, link=False) as (data_from, data_to):\n    if node_group_name in data_from.node_groups:\n        data_to.node_groups = [node_group_name]\n\n# Access the node group\nnode_group_place_spheres = bpy.data.node_groups[node_group_name]\n\n# Print all the node names inside the node group\nprint(f\"Nodes in node group '{node_group_name}':\")\nfor node in node_group_place_spheres.nodes:\n    print(node.name)\n</pre> # option 1: Load the node group to the current blend scene #TODO Make this it's own utility tool import bpy # Path to the blend file blend_file_path = \"docs/cube_gn_position.blend\" node_group_name = \"gn_place_spheres\"  # Load only the node group from the blend file with bpy.data.libraries.load(blend_file_path, link=False) as (data_from, data_to):     if node_group_name in data_from.node_groups:         data_to.node_groups = [node_group_name]  # Access the node group node_group_place_spheres = bpy.data.node_groups[node_group_name]  # Print all the node names inside the node group print(f\"Nodes in node group '{node_group_name}':\") for node in node_group_place_spheres.nodes:     print(node.name) <pre>Nodes in node group 'gn_place_spheres':\nGroup Input\nGroup Output\nInstance on Points\nUV Sphere\n</pre> In\u00a0[67]: Copied! <pre># option 2: Open the compeletely new blend file and access the node group\n#bpy.ops.wm.open_mainfile(filepath=\"cube_gn_position.blend\")\n\n# Access the node group\n#node_group_place_spheres = bpy.data.node_groups[\"gn_place_spheres\"]\n\n# Print all the node names inside the node group\n#print(\"Nodes in node group 'gn_place_spheres':\")\n#for node in node_group_place_spheres.nodes:\n#    print(node.name)\n</pre> # option 2: Open the compeletely new blend file and access the node group #bpy.ops.wm.open_mainfile(filepath=\"cube_gn_position.blend\")  # Access the node group #node_group_place_spheres = bpy.data.node_groups[\"gn_place_spheres\"]  # Print all the node names inside the node group #print(\"Nodes in node group 'gn_place_spheres':\") #for node in node_group_place_spheres.nodes: #    print(node.name) In\u00a0[68]: Copied! <pre>fresh_scene()\nimport mathutils\nimport databpy as db\n\n# Old way\n# Create a new mesh and object for the point cloud\n#mesh = bpy.data.meshes.new(\"HelloMesh\")\n#my_point_obj = bpy.data.objects.new(\"HelloPoint\", mesh)\n#points = [mathutils.Vector((6, 4, 0))]  # One point at coordinates\n# Apply the points to the mesh\n#mesh.from_pydata(vertices = points, edges=[], faces=[])\n#mesh.update()\n#bpy.context.collection.objects.link(my_point_obj)\n\n#new way:\n\nimport numpy as np\nimport databpy as db\n\nsingle_vertex = np.array([[6, 4, 0]])\n\n# Create a mesh object with the single vertex\nmy_point_obj = db.create_object(single_vertex, name=\"SinglePoint\")\n\n# Print the name of the created object\nprint(my_point_obj.name)\n\nbpy.context.scene.render.resolution_x = 300\nbpy.context.scene.render.resolution_y = 200\nrender_result()\n</pre> fresh_scene() import mathutils import databpy as db  # Old way # Create a new mesh and object for the point cloud #mesh = bpy.data.meshes.new(\"HelloMesh\") #my_point_obj = bpy.data.objects.new(\"HelloPoint\", mesh) #points = [mathutils.Vector((6, 4, 0))]  # One point at coordinates # Apply the points to the mesh #mesh.from_pydata(vertices = points, edges=[], faces=[]) #mesh.update() #bpy.context.collection.objects.link(my_point_obj)  #new way:  import numpy as np import databpy as db  single_vertex = np.array([[6, 4, 0]])  # Create a mesh object with the single vertex my_point_obj = db.create_object(single_vertex, name=\"SinglePoint\")  # Print the name of the created object print(my_point_obj.name)  bpy.context.scene.render.resolution_x = 300 bpy.context.scene.render.resolution_y = 200 render_result() <pre>SinglePoint\n</pre> In\u00a0[69]: Copied! <pre>modifier = my_point_obj.modifiers.new(name=\"GeometryNodes\", type='NODES')\nmodifier.node_group = node_group_place_spheres\nrender_result()\n</pre> modifier = my_point_obj.modifiers.new(name=\"GeometryNodes\", type='NODES') modifier.node_group = node_group_place_spheres render_result() In\u00a0[70]: Copied! <pre>my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 4 # set radius\nrender_result()\n</pre> my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 4 # set radius render_result() In\u00a0[71]: Copied! <pre>fresh_scene()\n\nsingle_vertex = np.array([(x, y, 0) for x, y in zip(x_values1, y_values1)])\n\nmy_point_obj = db.create_object(single_vertex, name=\"Deno\")\n\nmesh = bpy.data.meshes.new(\"HelloDenoMesh\")\nmy_point_obj = bpy.data.objects.new(\"HelloDeno\", mesh)\n\npoints = [mathutils.Vector((x, y, 0)) for x, y in zip(x_values1, y_values1)] \n\n# Apply the points to the mesh\nmesh.from_pydata(vertices=points, edges=[], faces=[])\nmesh.update()\nbpy.context.collection.objects.link(my_point_obj)\n\n\nmodifier = my_point_obj.modifiers.new(name=\"GeometryNodes\", type='NODES')\nmodifier.node_group = node_group_place_spheres\n\nmy_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 0.2  # Set radius\n\ncamera_from_above()\nrender_result()\n</pre> fresh_scene()  single_vertex = np.array([(x, y, 0) for x, y in zip(x_values1, y_values1)])  my_point_obj = db.create_object(single_vertex, name=\"Deno\")  mesh = bpy.data.meshes.new(\"HelloDenoMesh\") my_point_obj = bpy.data.objects.new(\"HelloDeno\", mesh)  points = [mathutils.Vector((x, y, 0)) for x, y in zip(x_values1, y_values1)]   # Apply the points to the mesh mesh.from_pydata(vertices=points, edges=[], faces=[]) mesh.update() bpy.context.collection.objects.link(my_point_obj)   modifier = my_point_obj.modifiers.new(name=\"GeometryNodes\", type='NODES') modifier.node_group = node_group_place_spheres  my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 0.2  # Set radius  camera_from_above() render_result() In\u00a0[72]: Copied! <pre>my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 0.1  # Set radius\n\nrender_result()\n</pre> my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 0.1  # Set radius  render_result() In\u00a0[73]: Copied! <pre># \ud83d\udca1 Now we can squeeze or change anything in geonodes!\nrender_result()\n</pre> # \ud83d\udca1 Now we can squeeze or change anything in geonodes! render_result() In\u00a0[74]: Copied! <pre># Also possible to change the data points\nimport pandas as pd\nurl = 'https://raw.githubusercontent.com/kolibril13/ipydrop/refs/heads/main/star.csv'\ndf = pd.read_csv(url)\ndf.head()\n</pre> # Also possible to change the data points import pandas as pd url = 'https://raw.githubusercontent.com/kolibril13/ipydrop/refs/heads/main/star.csv' df = pd.read_csv(url) df.head() Out[74]: x y 0 58.213608 91.881892 1 58.196054 92.214989 2 58.718231 90.310532 3 57.278373 89.907607 4 58.082020 92.008145 In\u00a0[75]: Copied! <pre>x_values = df['x'] / 10 \ny_values = df['y'] / 10 * 0.8\n\nplt.axis('equal');\nplt.scatter(x_values, y_values);\n</pre> x_values = df['x'] / 10  y_values = df['y'] / 10 * 0.8  plt.axis('equal'); plt.scatter(x_values, y_values); In\u00a0[76]: Copied! <pre># Only update the vertex positions without clearing the geometry\nfor i, (x, y) in enumerate(zip(x_values, y_values)):\n    my_point_obj.data.vertices[i].co = (x, y, 0)\n\n# Update the mesh and force Blender to recalculate\nmy_point_obj.data.update()\nbpy.context.view_layer.update()\n</pre> # Only update the vertex positions without clearing the geometry for i, (x, y) in enumerate(zip(x_values, y_values)):     my_point_obj.data.vertices[i].co = (x, y, 0)  # Update the mesh and force Blender to recalculate my_point_obj.data.update() bpy.context.view_layer.update() In\u00a0[77]: Copied! <pre>render_result()\n</pre> render_result() <pre>[I 2025-01-13 20:32:27.399 ServerApp] Saving file at /docs/n2data_simple.ipynb\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"n2data_simple/#simple-data","title":"Simple data\u00b6","text":""},{"location":"n2data_simple/#loading-pre-defined-geometry-nodes","title":"Loading Pre-Defined Geometry Nodes\u00b6","text":""},{"location":"n2databpy/","title":"Databpy","text":"In\u00a0[2]: Copied! <pre>import numpy as np\nimport databpy as db\n\nvertex = np.array([[0, 0, 0]])  \nobj = db.create_bob(vertex, name=\"Mesh1\")\nobj.name\n</pre> import numpy as np import databpy as db  vertex = np.array([[0, 0, 0]])   obj = db.create_bob(vertex, name=\"Mesh1\") obj.name Out[2]: <pre>'Mesh1'</pre> In\u00a0[3]: Copied! <pre>obj.position\n</pre> obj.position Out[3]: <pre>array([[0., 0., 0.]])</pre> In\u00a0[4]: Copied! <pre>import numpy as np\nimport databpy as db\n\ncoords = np.random.rand(20, 3)  \nobj = db.create_bob(coords, name=\"Mesh2\")\nobj.name\n</pre> import numpy as np import databpy as db  coords = np.random.rand(20, 3)   obj = db.create_bob(coords, name=\"Mesh2\") obj.name Out[4]: <pre>'Mesh2'</pre> In\u00a0[5]: Copied! <pre>obj.position[:3] # first three\n</pre> obj.position[:3] # first three Out[5]: <pre>array([[0.1291904 , 0.00317181, 0.5135445 ],\n       [0.94508129, 0.86277646, 0.97644675],\n       [0.00203336, 0.87146598, 0.40898171]])</pre> In\u00a0[6]: Copied! <pre>%%time\nimport numpy as np\nimport databpy as db\n\n# Generate 2 million random 3D points\ncoords = np.random.rand(2_000_000, 3)\n\n# Create a mesh object using databpy\nobj = db.create_bob(coords, name=\"Mesh2M\")\nprint(obj.name)\n</pre> %%time import numpy as np import databpy as db  # Generate 2 million random 3D points coords = np.random.rand(2_000_000, 3)  # Create a mesh object using databpy obj = db.create_bob(coords, name=\"Mesh2M\") print(obj.name) <pre>Mesh2M\nCPU times: user 701 ms, sys: 40 ms, total: 741 ms\nWall time: 736 ms\n</pre> In\u00a0[7]: Copied! <pre>import numpy as np\nimport polars as pl\nfrom csv_importer.parsers import polars_df_to_bob\n\ndf = pl.DataFrame(\n    {\n        \"Intensity\": [10, 20],\n    }\n)\nbob = polars_df_to_bob(df, name=\"MeshInt\")\n</pre> import numpy as np import polars as pl from csv_importer.parsers import polars_df_to_bob  df = pl.DataFrame(     {         \"Intensity\": [10, 20],     } ) bob = polars_df_to_bob(df, name=\"MeshInt\") In\u00a0[8]: Copied! <pre>import numpy as np\nimport polars as pl\nfrom csv_importer.parsers import polars_df_to_bob\n\ndf = pl.DataFrame(\n    {\n        \"opacity\": [0.34, 0.92],\n    }\n)\nbob = polars_df_to_bob(df, name=\"MeshFloat\")\n</pre> import numpy as np import polars as pl from csv_importer.parsers import polars_df_to_bob  df = pl.DataFrame(     {         \"opacity\": [0.34, 0.92],     } ) bob = polars_df_to_bob(df, name=\"MeshFloat\") In\u00a0[9]: Copied! <pre>import numpy as np\nimport polars as pl\nfrom csv_importer.parsers import polars_df_to_bob\n\ndf = pl.DataFrame(\n    {\n        \"Is_Visible\": [True, False],\n    }\n)\nbob = polars_df_to_bob(df, name=\"MeshBool\")\n</pre> import numpy as np import polars as pl from csv_importer.parsers import polars_df_to_bob  df = pl.DataFrame(     {         \"Is_Visible\": [True, False],     } ) bob = polars_df_to_bob(df, name=\"MeshBool\") In\u00a0[10]: Copied! <pre>import numpy as np\nimport polars as pl\nfrom csv_importer.parsers import polars_df_to_bob\n\ndf = pl.DataFrame({\n    \"Star\": [\n        [3.4, 3.5, 0.0],\n        [3.1, 5.6, 0.0]\n    ]\n})\nobj = polars_df_to_bob(df, name=\"MeshVector\")\n</pre> import numpy as np import polars as pl from csv_importer.parsers import polars_df_to_bob  df = pl.DataFrame({     \"Star\": [         [3.4, 3.5, 0.0],         [3.1, 5.6, 0.0]     ] }) obj = polars_df_to_bob(df, name=\"MeshVector\") In\u00a0[11]: Copied! <pre>import numpy as np\nimport polars as pl\nfrom csv_importer.parsers import polars_df_to_bob\n\ndf = pl.DataFrame({\n    \"String\": [\"Hello\", \"World\"],\n})\n# Stings are not supported\nobj = polars_df_to_bob(df, name=\"MeshVector\")\n</pre> import numpy as np import polars as pl from csv_importer.parsers import polars_df_to_bob  df = pl.DataFrame({     \"String\": [\"Hello\", \"World\"], }) # Stings are not supported obj = polars_df_to_bob(df, name=\"MeshVector\") In\u00a0[12]: Copied! <pre># all together\nimport numpy as np\nimport polars as pl\nfrom csv_importer.parsers import polars_df_to_bob\n\ndf = pl.DataFrame({\n    \"Intensity\": [10, 20],\n    \"opacity\": [0.34, 0.92],\n    \"Is_Visible\": [True, False],\n    \"Star\": [\n        [3.4, 3.5, 0.0],\n        [3.1, 5.6, 0.0]\n    ]\n})\nobj = polars_df_to_bob(df, name=\"MeshVector\")\n</pre> # all together import numpy as np import polars as pl from csv_importer.parsers import polars_df_to_bob  df = pl.DataFrame({     \"Intensity\": [10, 20],     \"opacity\": [0.34, 0.92],     \"Is_Visible\": [True, False],     \"Star\": [         [3.4, 3.5, 0.0],         [3.1, 5.6, 0.0]     ] }) obj = polars_df_to_bob(df, name=\"MeshVector\") In\u00a0[13]: Copied! <pre>from pathlib import Path\nfrom csv_importer.csv import load_csv\n\ncsv_path = Path.home() / \"projects\" / \"blender_csv_import\" / \"docs\" / \"sample_datasets\" / \"data_california_housing.csv\"\n\n# `load_csv` is like `like polars_df_to_bob`, but with a csv path input\nobj = load_csv(csv_path) \n \nprint(obj.name)\n</pre> from pathlib import Path from csv_importer.csv import load_csv  csv_path = Path.home() / \"projects\" / \"blender_csv_import\" / \"docs\" / \"sample_datasets\" / \"data_california_housing.csv\"  # `load_csv` is like `like polars_df_to_bob`, but with a csv path input obj = load_csv(csv_path)    print(obj.name) <pre>CSV_data_california_housing\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"n2databpy/#databpy","title":"Databpy\u00b6","text":"<p>https://github.com/BradyAJohnston/databpy</p>"},{"location":"n2databpy/#setting-attributes","title":"Setting Attributes\u00b6","text":"<p>To run the code below, first install the Blender extension from the following link: https://extensions.blender.org/add-ons/csv-importer/</p>"},{"location":"n3data_attributes/","title":"Data attributes","text":"In\u00a0[35]: Copied! <pre>import bpy\nfrom IPython.display import display, Image\n\ndef fresh_scene():\n    # Deselect all objects\n    bpy.ops.object.select_all(action='DESELECT')\n    # Select all objects except cameras\n    for obj in bpy.context.scene.objects:\n        if  obj.type != 'CAMERA':\n            obj.select_set(True)\n        else:\n            obj.select_set(False)\n    bpy.ops.object.delete()\n    \n    # add light\n    bpy.ops.object.light_add(type='SUN')\n    sun = bpy.context.object\n\n    sun.location = (0, 0, 0)\n    from math import radians\n    sun.rotation_euler = (radians(204), radians(-133), radians(-67))\n    sun.data.energy = 5  \n\n\ndef render_result():\n    bpy.ops.render.render()\n    bpy.data.images['Render Result'].save_render(filepath=\"img.png\")\n    display(Image(filename=\"img.png\"))\n\nbpy.context.scene.render.resolution_x = 500\nbpy.context.scene.render.resolution_y = 200\n</pre> import bpy from IPython.display import display, Image  def fresh_scene():     # Deselect all objects     bpy.ops.object.select_all(action='DESELECT')     # Select all objects except cameras     for obj in bpy.context.scene.objects:         if  obj.type != 'CAMERA':             obj.select_set(True)         else:             obj.select_set(False)     bpy.ops.object.delete()          # add light     bpy.ops.object.light_add(type='SUN')     sun = bpy.context.object      sun.location = (0, 0, 0)     from math import radians     sun.rotation_euler = (radians(204), radians(-133), radians(-67))     sun.data.energy = 5     def render_result():     bpy.ops.render.render()     bpy.data.images['Render Result'].save_render(filepath=\"img.png\")     display(Image(filename=\"img.png\"))  bpy.context.scene.render.resolution_x = 500 bpy.context.scene.render.resolution_y = 200 In\u00a0[36]: Copied! <pre># temp\nbpy.ops.wm.save_as_mainfile(filepath=\"scene.blend\")\n</pre> # temp bpy.ops.wm.save_as_mainfile(filepath=\"scene.blend\") <pre>Info: Saved \"scene.blend\"\n</pre> Out[36]: <pre>{'FINISHED'}</pre> In\u00a0[37]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_plane_add(size=3, location=(0, 0, 0))  \nplane = bpy.context.object\n\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_plane_add(size=3, location=(0, 0, 0))   plane = bpy.context.object  render_result() In\u00a0[38]: Copied! <pre>num_vertices = len(plane.data.vertices)\nnum_vertices\n</pre> num_vertices = len(plane.data.vertices) num_vertices Out[38]: <pre>4</pre> In\u00a0[39]: Copied! <pre>vertices = [(v.co.x, v.co.y, v.co.z) for v in plane.data.vertices]\nimport pandas as pd\ndf = pd.DataFrame(vertices, columns=['X', 'Y', 'Z'])\ndf\n</pre> vertices = [(v.co.x, v.co.y, v.co.z) for v in plane.data.vertices] import pandas as pd df = pd.DataFrame(vertices, columns=['X', 'Y', 'Z']) df Out[39]: X Y Z 0 -1.5 -1.5 0.0 1 1.5 -1.5 0.0 2 -1.5 1.5 0.0 3 1.5 1.5 0.0 In\u00a0[40]: Copied! <pre>attr_name = 'my_float'\n\n# 'POINT' domain means each vertex gets the value\nattr = plane.data.attributes.new(name=attr_name,type='FLOAT',domain='POINT')\n\nvalues = [2.0, 3.0, 4.2, 5.2]\nattr.data.foreach_set('value', values)\nplane.data.update()\n\nrender_result()\n</pre> attr_name = 'my_float'  # 'POINT' domain means each vertex gets the value attr = plane.data.attributes.new(name=attr_name,type='FLOAT',domain='POINT')  values = [2.0, 3.0, 4.2, 5.2] attr.data.foreach_set('value', values) plane.data.update()  render_result() In\u00a0[41]: Copied! <pre># we can confirm this by checking with a dataframe:\ndf = pd.DataFrame({\n    'X': [v.co.x for v in plane.data.vertices],\n    'Y': [v.co.y for v in plane.data.vertices],\n    'Z': [v.co.z for v in plane.data.vertices],\n    'my_float': [val.value for val in plane.data.attributes['my_float'].data]\n})\n\ndf\n</pre> # we can confirm this by checking with a dataframe: df = pd.DataFrame({     'X': [v.co.x for v in plane.data.vertices],     'Y': [v.co.y for v in plane.data.vertices],     'Z': [v.co.z for v in plane.data.vertices],     'my_float': [val.value for val in plane.data.attributes['my_float'].data] })  df Out[41]: X Y Z my_float 0 -1.5 -1.5 0.0 2.0 1 1.5 -1.5 0.0 3.0 2 -1.5 1.5 0.0 4.2 3 1.5 1.5 0.0 5.2 In\u00a0[42]: Copied! <pre>blend_file_path = \"cube_gn_attribute.blend\"\nnode_group_name = \"gn_place_by_attribute\"\n\n# Load only the node group from the blend file\nwith bpy.data.libraries.load(blend_file_path, link=False) as (data_from, data_to):\n    if node_group_name in data_from.node_groups:\n        data_to.node_groups = [node_group_name]\n\n# Access the node group\nnode_group_place_spheres_attributes = bpy.data.node_groups[node_group_name]\n\n# Print all the node names inside the node group\nprint(f\"Nodes in node group '{node_group_name}':\")\nfor node in node_group_place_spheres_attributes.nodes:\n    print(node.name)\n</pre> blend_file_path = \"cube_gn_attribute.blend\" node_group_name = \"gn_place_by_attribute\"  # Load only the node group from the blend file with bpy.data.libraries.load(blend_file_path, link=False) as (data_from, data_to):     if node_group_name in data_from.node_groups:         data_to.node_groups = [node_group_name]  # Access the node group node_group_place_spheres_attributes = bpy.data.node_groups[node_group_name]  # Print all the node names inside the node group print(f\"Nodes in node group '{node_group_name}':\") for node in node_group_place_spheres_attributes.nodes:     print(node.name) <pre>Nodes in node group 'gn_place_by_attribute':\nGroup Input\nGroup Output\nInstance on Points\nNamed Attribute\nUV Sphere\n</pre> In\u00a0[43]: Copied! <pre># add geometry nodes\nmodifier = plane.modifiers.new(name=\"GeometryNodes\", type='NODES')\nmodifier.node_group = node_group_place_spheres_attributes\nplane.data.update()\n\nrender_result()\n</pre> # add geometry nodes modifier = plane.modifiers.new(name=\"GeometryNodes\", type='NODES') modifier.node_group = node_group_place_spheres_attributes plane.data.update()  render_result() In\u00a0[44]: Copied! <pre>values = [10.0, 10.0, 2.2, 13.2]\nattr.data.foreach_set('value', values)\nplane.data.update()\n\nrender_result()\n</pre> values = [10.0, 10.0, 2.2, 13.2] attr.data.foreach_set('value', values) plane.data.update()  render_result() In\u00a0[45]: Copied! <pre># remove geometry nodes modifier again\nmodifier = plane.modifiers.get(\"GeometryNodes\")\nplane.modifiers.remove(modifier)\nrender_result()\n</pre> # remove geometry nodes modifier again modifier = plane.modifiers.get(\"GeometryNodes\") plane.modifiers.remove(modifier) render_result() In\u00a0[46]: Copied! <pre># Other datatypes are:# 'FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BYTE_COLOR', 'STRING', 'BOOLEAN', 'FLOAT2', 'INT8', 'INT32_2D', 'QUATERNION', 'FLOAT4X4\n</pre> # Other datatypes are:# 'FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BYTE_COLOR', 'STRING', 'BOOLEAN', 'FLOAT2', 'INT8', 'INT32_2D', 'QUATERNION', 'FLOAT4X4  In\u00a0[47]: Copied! <pre>if 'my_int' in plane.data.attributes:\n    plane.data.attributes.remove(plane.data.attributes['my_int'])\n\n# 'POINT' domain means each vertex gets the value\nattr = plane.data.attributes.new(name=\"my_int\",type='INT',domain='POINT')\nvalues = [2, 3, 4, 2]\nattr.data.foreach_set('value', values)\nplane.data.update()\nrender_result()\n</pre> if 'my_int' in plane.data.attributes:     plane.data.attributes.remove(plane.data.attributes['my_int'])  # 'POINT' domain means each vertex gets the value attr = plane.data.attributes.new(name=\"my_int\",type='INT',domain='POINT') values = [2, 3, 4, 2] attr.data.foreach_set('value', values) plane.data.update() render_result() In\u00a0[48]: Copied! <pre>if 'my_color' in plane.data.attributes:\n    plane.data.attributes.remove(plane.data.attributes['my_color'])\n\nattr = plane.data.attributes.new(name='my_color', type='FLOAT_COLOR', domain='POINT')\nvalues = [\n    (1.0, 0.5, 0.0, 1.0), # \"Orange 1\n    (1.0, 0.4, 0.1, 1.0), # \"Orange 2\n    (1.0, 0.3, 0.2, 1.0), # \"Orange 3\n    (1.0, 0.2, 0.1, 1.0), # \"Orange 4\n]\nfor i, color in enumerate(values):\n    attr.data[i].color = color\n\nplane.data.update()\nrender_result()\n</pre> if 'my_color' in plane.data.attributes:     plane.data.attributes.remove(plane.data.attributes['my_color'])  attr = plane.data.attributes.new(name='my_color', type='FLOAT_COLOR', domain='POINT') values = [     (1.0, 0.5, 0.0, 1.0), # \"Orange 1     (1.0, 0.4, 0.1, 1.0), # \"Orange 2     (1.0, 0.3, 0.2, 1.0), # \"Orange 3     (1.0, 0.2, 0.1, 1.0), # \"Orange 4 ] for i, color in enumerate(values):     attr.data[i].color = color  plane.data.update() render_result() In\u00a0[49]: Copied! <pre># add shader nodes\nmaterial = bpy.data.materials.new(name=\"MyMaterial\")\nmaterial.use_nodes = True\n\nnodes = material.node_tree.nodes\nlinks = material.node_tree.links\n\nfor node in nodes:\n    nodes.remove(node)\n\nattribute_node = nodes.new(type=\"ShaderNodeAttribute\")\nattribute_node.location = (-600, 0)\nattribute_node.attribute_name = \"my_color\"\n\nprincipled_node = nodes.new(type=\"ShaderNodeBsdfPrincipled\")\nprincipled_node.location = (-200, 0)\n\noutput_node = nodes.new(type=\"ShaderNodeOutputMaterial\")\noutput_node.location = (200, 0)\n\nlinks.new(attribute_node.outputs['Color'], principled_node.inputs['Base Color'])\nlinks.new(principled_node.outputs['BSDF'], output_node.inputs['Surface'])\n\n# Ensure the object has at least one material slot\nif len(plane.data.materials) == 0:\n    plane.data.materials.append(material)\nelse:\n    plane.data.materials[0] = material\n\nrender_result()\n</pre> # add shader nodes material = bpy.data.materials.new(name=\"MyMaterial\") material.use_nodes = True  nodes = material.node_tree.nodes links = material.node_tree.links  for node in nodes:     nodes.remove(node)  attribute_node = nodes.new(type=\"ShaderNodeAttribute\") attribute_node.location = (-600, 0) attribute_node.attribute_name = \"my_color\"  principled_node = nodes.new(type=\"ShaderNodeBsdfPrincipled\") principled_node.location = (-200, 0)  output_node = nodes.new(type=\"ShaderNodeOutputMaterial\") output_node.location = (200, 0)  links.new(attribute_node.outputs['Color'], principled_node.inputs['Base Color']) links.new(principled_node.outputs['BSDF'], output_node.inputs['Surface'])  # Ensure the object has at least one material slot if len(plane.data.materials) == 0:     plane.data.materials.append(material) else:     plane.data.materials[0] = material  render_result() In\u00a0[50]: Copied! <pre># Add vector attribute\n\nif 'my_vector' in plane.data.attributes:\n    plane.data.attributes.remove(plane.data.attributes['my_vector'])\n\nattr = plane.data.attributes.new(name='my_vector', type='FLOAT_VECTOR', domain='POINT')\nvalues = [\n    (0.4, 0.4, -1.0),\n    (0.2, 0.3, 0.9),\n    (0.5, 0.5, 0.5),\n    (0.6, 0.9, 1.3)\n]\nfor i, vector in enumerate(values):\n    attr.data[i].vector = vector\n\nplane.data.update()\n</pre> # Add vector attribute  if 'my_vector' in plane.data.attributes:     plane.data.attributes.remove(plane.data.attributes['my_vector'])  attr = plane.data.attributes.new(name='my_vector', type='FLOAT_VECTOR', domain='POINT') values = [     (0.4, 0.4, -1.0),     (0.2, 0.3, 0.9),     (0.5, 0.5, 0.5),     (0.6, 0.9, 1.3) ] for i, vector in enumerate(values):     attr.data[i].vector = vector  plane.data.update() In\u00a0[51]: Copied! <pre>geo_nodes = plane.modifiers.new(name=\"GeometryNodes\", type=\"NODES\")\n\nnode_group = bpy.data.node_groups.new(name=\"GeometryNodes\", type=\"GeometryNodeTree\")\ngeo_nodes.node_group = node_group\n\ngroup_input = node_group.nodes.new(type=\"NodeGroupInput\")\ngroup_input.location = (0, 0)\n\ngroup_output = node_group.nodes.new(type=\"NodeGroupOutput\")\ngroup_output.location = (600, 0)\n\nnode_group.interface.new_socket(name=\"Geometry\", in_out=\"INPUT\", socket_type=\"NodeSocketGeometry\")\nnode_group.interface.new_socket(name=\"Geometry\", in_out=\"OUTPUT\", socket_type=\"NodeSocketGeometry\")\n\nset_position = node_group.nodes.new(type=\"GeometryNodeSetPosition\")\nset_position.location = (300, 0)\n\nnamed_attribute = node_group.nodes.new(type=\"GeometryNodeInputNamedAttribute\")\nnamed_attribute.location = (100, -200)\nnamed_attribute.data_type = 'FLOAT_VECTOR'\nnamed_attribute.inputs[\"Name\"].default_value = \"my_vector\"\n\nnode_group.links.new(group_input.outputs[\"Geometry\"], set_position.inputs[\"Geometry\"])\nnode_group.links.new(set_position.outputs[\"Geometry\"], group_output.inputs[\"Geometry\"])\n\nnode_group.links.new(named_attribute.outputs[\"Attribute\"], set_position.inputs[\"Offset\"])\n\nrender_result()\n</pre>  geo_nodes = plane.modifiers.new(name=\"GeometryNodes\", type=\"NODES\")  node_group = bpy.data.node_groups.new(name=\"GeometryNodes\", type=\"GeometryNodeTree\") geo_nodes.node_group = node_group  group_input = node_group.nodes.new(type=\"NodeGroupInput\") group_input.location = (0, 0)  group_output = node_group.nodes.new(type=\"NodeGroupOutput\") group_output.location = (600, 0)  node_group.interface.new_socket(name=\"Geometry\", in_out=\"INPUT\", socket_type=\"NodeSocketGeometry\") node_group.interface.new_socket(name=\"Geometry\", in_out=\"OUTPUT\", socket_type=\"NodeSocketGeometry\")  set_position = node_group.nodes.new(type=\"GeometryNodeSetPosition\") set_position.location = (300, 0)  named_attribute = node_group.nodes.new(type=\"GeometryNodeInputNamedAttribute\") named_attribute.location = (100, -200) named_attribute.data_type = 'FLOAT_VECTOR' named_attribute.inputs[\"Name\"].default_value = \"my_vector\"  node_group.links.new(group_input.outputs[\"Geometry\"], set_position.inputs[\"Geometry\"]) node_group.links.new(set_position.outputs[\"Geometry\"], group_output.inputs[\"Geometry\"])  node_group.links.new(named_attribute.outputs[\"Attribute\"], set_position.inputs[\"Offset\"])  render_result() In\u00a0[52]: Copied! <pre>import pandas as pd\nimport bpy\n\n# Assume you are working with the plane object\nplane = bpy.data.objects['Plane']\n\n# Create the DataFrame for coordinates\ndf = pd.DataFrame({\n    'X': [v.co.x for v in plane.data.vertices],\n    'Y': [v.co.y for v in plane.data.vertices],\n    'Z': [v.co.z for v in plane.data.vertices]\n})\n\n# Add custom attributes if they exist\n\n# Add my_float attribute\nif 'my_float' in plane.data.attributes:\n    df['my_float'] = [attr.value for attr in plane.data.attributes['my_float'].data]\n\n# Add my_int attribute\nif 'my_int' in plane.data.attributes:\n    df['my_int'] = [attr.value for attr in plane.data.attributes['my_int'].data]\n\n# Add my_color attribute and round to 2 decimal places\nif 'my_color' in plane.data.attributes:\n    df['my_color'] = [tuple(round(c, 3) for c in attr.color) for attr in plane.data.attributes['my_color'].data]\n\n# Add my_vector attribute\nif 'my_vector' in plane.data.attributes:\n    df['my_vector'] = [tuple(round(c, 3) for c in attr.vector) for attr in plane.data.attributes['my_vector'].data]\n\n# Display the DataFrame\ndf\n</pre> import pandas as pd import bpy  # Assume you are working with the plane object plane = bpy.data.objects['Plane']  # Create the DataFrame for coordinates df = pd.DataFrame({     'X': [v.co.x for v in plane.data.vertices],     'Y': [v.co.y for v in plane.data.vertices],     'Z': [v.co.z for v in plane.data.vertices] })  # Add custom attributes if they exist  # Add my_float attribute if 'my_float' in plane.data.attributes:     df['my_float'] = [attr.value for attr in plane.data.attributes['my_float'].data]  # Add my_int attribute if 'my_int' in plane.data.attributes:     df['my_int'] = [attr.value for attr in plane.data.attributes['my_int'].data]  # Add my_color attribute and round to 2 decimal places if 'my_color' in plane.data.attributes:     df['my_color'] = [tuple(round(c, 3) for c in attr.color) for attr in plane.data.attributes['my_color'].data]  # Add my_vector attribute if 'my_vector' in plane.data.attributes:     df['my_vector'] = [tuple(round(c, 3) for c in attr.vector) for attr in plane.data.attributes['my_vector'].data]  # Display the DataFrame df Out[52]: X Y Z my_float my_int my_color my_vector 0 -1.5 -1.5 0.0 10.0 2 (1.0, 0.5, 0.0, 1.0) (0.4, 0.4, -1.0) 1 1.5 -1.5 0.0 10.0 3 (1.0, 0.4, 0.1, 1.0) (0.2, 0.3, 0.9) 2 -1.5 1.5 0.0 2.2 4 (1.0, 0.3, 0.2, 1.0) (0.5, 0.5, 0.5) 3 1.5 1.5 0.0 13.2 2 (1.0, 0.2, 0.1, 1.0) (0.6, 0.9, 1.3) In\u00a0[53]: Copied! <pre>import random\nmaterial = bpy.data.materials.new(\"MyMaterial\")\nmaterial.use_nodes = True\nnodes = material.node_tree.nodes\nlinks = material.node_tree.links\nnodes.clear()\nattr_node = nodes.new(\"ShaderNodeAttribute\")\nbsdf_node = nodes.new(\"ShaderNodeBsdfPrincipled\")\noutput_node = nodes.new(\"ShaderNodeOutputMaterial\")\nlinks.new(attr_node.outputs['Color'], bsdf_node.inputs['Base Color'])\nlinks.new(bsdf_node.outputs['BSDF'], output_node.inputs['Surface'])\n\n\nprint(\"Vertex\")\nfresh_scene()\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, segments=20, ring_count=10)\nobj = bpy.context.object\nmesh = obj.data\nattr_name = 'my_point_color'\nattr = mesh.attributes.new(attr_name, 'FLOAT_VECTOR', 'POINT')\ncolors = [c for _ in mesh.vertices for c in random.choice([(1, 0.5, 0), (0, 0.5, 1)])]\nattr.data.foreach_set('vector', colors)\nmesh.update()\nattr_node.attribute_name = attr_name\nobj.data.materials.append(material)\nrender_result()\n</pre> import random material = bpy.data.materials.new(\"MyMaterial\") material.use_nodes = True nodes = material.node_tree.nodes links = material.node_tree.links nodes.clear() attr_node = nodes.new(\"ShaderNodeAttribute\") bsdf_node = nodes.new(\"ShaderNodeBsdfPrincipled\") output_node = nodes.new(\"ShaderNodeOutputMaterial\") links.new(attr_node.outputs['Color'], bsdf_node.inputs['Base Color']) links.new(bsdf_node.outputs['BSDF'], output_node.inputs['Surface'])   print(\"Vertex\") fresh_scene() bpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, segments=20, ring_count=10) obj = bpy.context.object mesh = obj.data attr_name = 'my_point_color' attr = mesh.attributes.new(attr_name, 'FLOAT_VECTOR', 'POINT') colors = [c for _ in mesh.vertices for c in random.choice([(1, 0.5, 0), (0, 0.5, 1)])] attr.data.foreach_set('vector', colors) mesh.update() attr_node.attribute_name = attr_name obj.data.materials.append(material) render_result() <pre>Vertex\n</pre> In\u00a0[54]: Copied! <pre>print(\"Face\")\nfresh_scene()\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, segments=20, ring_count=10)\nobj = bpy.context.object\nmesh = obj.data\nattr_name = 'my_color'\nattr = mesh.attributes.new(attr_name, 'FLOAT_VECTOR', 'FACE')\ncolors = [c for _ in mesh.polygons for c in random.choice([(1, 0.5, 0), (0, 0.5, 1)])]\nattr.data.foreach_set('vector', colors)\nmesh.update()\nattr_node.attribute_name = attr_name\nobj.data.materials.append(material)\nrender_result()\n</pre> print(\"Face\") fresh_scene() bpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, segments=20, ring_count=10) obj = bpy.context.object mesh = obj.data attr_name = 'my_color' attr = mesh.attributes.new(attr_name, 'FLOAT_VECTOR', 'FACE') colors = [c for _ in mesh.polygons for c in random.choice([(1, 0.5, 0), (0, 0.5, 1)])] attr.data.foreach_set('vector', colors) mesh.update() attr_node.attribute_name = attr_name obj.data.materials.append(material) render_result() <pre>Face\n</pre> In\u00a0[55]: Copied! <pre>print(\"Edge\")\nfresh_scene()\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, segments=20, ring_count=10)\nobj = bpy.context.object\nmesh = obj.data\nattr_name = 'my_edge_color'\nattr = mesh.attributes.new(attr_name, 'FLOAT_VECTOR', 'EDGE')\ncolors = [c for _ in mesh.edges for c in random.choice([(1, 0.5, 0), (0, 0.5, 1)])]\nattr.data.foreach_set('vector', colors)\nmesh.update()\nattr_node.attribute_name = attr_name\nobj.data.materials.append(material)\nrender_result()\n</pre> print(\"Edge\") fresh_scene() bpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, segments=20, ring_count=10) obj = bpy.context.object mesh = obj.data attr_name = 'my_edge_color' attr = mesh.attributes.new(attr_name, 'FLOAT_VECTOR', 'EDGE') colors = [c for _ in mesh.edges for c in random.choice([(1, 0.5, 0), (0, 0.5, 1)])] attr.data.foreach_set('vector', colors) mesh.update() attr_node.attribute_name = attr_name obj.data.materials.append(material) render_result()  <pre>Edge\n</pre>"},{"location":"n3data_attributes/#data-attributes","title":"Data attributes\u00b6","text":""},{"location":"n3data_attributes/#adding-a-float","title":"Adding a Float\u00b6","text":""},{"location":"n3data_attributes/#now-lets-use-the-attribute-in-geometry-nodes","title":"Now let's use the attribute in Geometry Nodes!\u00b6","text":""},{"location":"n3data_attributes/#add-int","title":"Add INT\u00b6","text":""},{"location":"n3data_attributes/#add-color","title":"ADD COLOR\u00b6","text":""},{"location":"n3data_attributes/#vertex-face-and-edge-domain","title":"Vertex, Face and Edge domain\u00b6","text":""},{"location":"n4_typst_examples/","title":"Typst","text":"In\u00a0[52]: Copied! <pre># Import helper functions just for the docs\nimport runpy\nmodule = runpy.run_path(\"/Users/jan-hendrik/projects/bpy-gallery/docs/render_utils.py\")\nglobals().update(module) # adds fresh_scene(), render_result(), load_paper_background()\n</pre> # Import helper functions just for the docs import runpy module = runpy.run_path(\"/Users/jan-hendrik/projects/bpy-gallery/docs/render_utils.py\") globals().update(module) # adds fresh_scene(), render_result(), load_paper_background() In\u00a0[\u00a0]: Copied! <pre>from typst_importer.typst_to_svg import typst_express\nfresh_scene()\n\nc = typst_express(\n    \"$ a = b/c$\",\n    scale_factor=200,\n    origin_to_char=True,\n    join_curves=True,\n)\nrender_result(collection=c)\n</pre> from typst_importer.typst_to_svg import typst_express fresh_scene()  c = typst_express(     \"$ a = b/c$\",     scale_factor=200,     origin_to_char=True,     join_curves=True, ) render_result(collection=c) In\u00a0[54]: Copied! <pre>fresh_scene()\nc = typst_express(\n    \"$ e = m c^2$\",\n    scale_factor=200,\n    origin_to_char=True,\n    join_curves=True,\n)\nrender_result(collection=c)\n</pre> fresh_scene() c = typst_express(     \"$ e = m c^2$\",     scale_factor=200,     origin_to_char=True,     join_curves=True, ) render_result(collection=c) In\u00a0[55]: Copied! <pre>fresh_scene()\ncontent = \"$ limits(integral)_a^b f(x) dif x $\" \nc = typst_express(content, name=\"Integral Example\")\nrender_result(collection=c)\n</pre> fresh_scene() content = \"$ limits(integral)_a^b f(x) dif x $\"  c = typst_express(content, name=\"Integral Example\") render_result(collection=c) In\u00a0[56]: Copied! <pre>fresh_scene()\nc = typst_express(\"\"\"\n#let korange() = text(fill: orange)[$k$]\n#let nblue() = text(fill: blue)[$n$]\n$ sum_(#korange() = 1)^#nblue() #korange() = (nblue()(nblue()+1)) / 2 $  \n\"\"\")\nrender_result(collection=c, width=\"600pt\")\n</pre> fresh_scene() c = typst_express(\"\"\" #let korange() = text(fill: orange)[$k$] #let nblue() = text(fill: blue)[$n$] $ sum_(#korange() = 1)^#nblue() #korange() = (nblue()(nblue()+1)) / 2 $   \"\"\") render_result(collection=c, width=\"600pt\") In\u00a0[64]: Copied! <pre>fresh_scene()\nc = typst_express(\"\"\"\n#set page(width: 500pt, height: auto, margin: 0cm, fill: none)\n\n#import \"@preview/codelst:2.0.1\": sourcecode\n#import \"@preview/tablex:0.0.8\": tablex\n#let sourcecode = sourcecode.with(frame: (code) =&gt; block(\n  radius: 5pt,\n  stroke: 2pt + luma(0),\n  inset: 30pt,\n  text(size: 30pt, code)\n))\n\n#sourcecode[```python\nfor i in range(0,10):\n  print(i)\n```]\n\"\"\")\nrender_result(collection=c, padding_factor=-0.4, width=\"900pt\")\n</pre> fresh_scene() c = typst_express(\"\"\" #set page(width: 500pt, height: auto, margin: 0cm, fill: none)  #import \"@preview/codelst:2.0.1\": sourcecode #import \"@preview/tablex:0.0.8\": tablex #let sourcecode = sourcecode.with(frame: (code) =&gt; block(   radius: 5pt,   stroke: 2pt + luma(0),   inset: 30pt,   text(size: 30pt, code) ))  #sourcecode[```python for i in range(0,10):   print(i) ```] \"\"\") render_result(collection=c, padding_factor=-0.4, width=\"900pt\") In\u00a0[61]: Copied! <pre>fresh_scene()\ncontent = \"\"\"\n#set page(width: 800pt, height: auto, margin: 0cm, fill: none)\n\n#import \"@preview/codelst:2.0.1\": sourcecode\n#import \"@preview/tablex:0.0.8\": tablex\n\n#let sourcecode = sourcecode.with(frame: (code) =&gt; block(\n  radius: 5pt,\n  stroke: 5pt + luma(0),\n  inset: 30pt,\n  text(size: 30pt, code)\n))\n\n#sourcecode[```python\n\nclass HelloWorld:\n    def __init__(self):\n        self.message = \"Hello, world!\"\n\n    def greet(self):\n        print(self.message)\n\nif __name__ == \"__main__\":\n    hello = HelloWorld()\n    hello.greet()\n```]\n\"\"\"\nc = typst_express(content)\nrender_result(collection=c , padding_factor=-0.4, width=\"900pt\")\n</pre> fresh_scene() content = \"\"\" #set page(width: 800pt, height: auto, margin: 0cm, fill: none)  #import \"@preview/codelst:2.0.1\": sourcecode #import \"@preview/tablex:0.0.8\": tablex  #let sourcecode = sourcecode.with(frame: (code) =&gt; block(   radius: 5pt,   stroke: 5pt + luma(0),   inset: 30pt,   text(size: 30pt, code) ))  #sourcecode[```python  class HelloWorld:     def __init__(self):         self.message = \"Hello, world!\"      def greet(self):         print(self.message)  if __name__ == \"__main__\":     hello = HelloWorld()     hello.greet() ```] \"\"\" c = typst_express(content) render_result(collection=c , padding_factor=-0.4, width=\"900pt\") In\u00a0[62]: Copied! <pre>fresh_scene()\ncontent = \"\"\"\n#set math.lr(size: 80%)\n$ integral.triple _V (nabla dot accent(F, arrow)) dif V = integral.surf_(partial V)  (accent(F, arrow) dot accent(n, arrow)) dif A $\n\"\"\"\nc = typst_express(content)\nrender_result(collection=c , padding_factor=-0.4, width=\"1200pt\")\n</pre> fresh_scene() content = \"\"\" #set math.lr(size: 80%) $ integral.triple _V (nabla dot accent(F, arrow)) dif V = integral.surf_(partial V)  (accent(F, arrow) dot accent(n, arrow)) dif A $ \"\"\" c = typst_express(content) render_result(collection=c , padding_factor=-0.4, width=\"1200pt\") In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"n4_typst_examples/#typst","title":"Typst\u00b6","text":""},{"location":"n4javascript/","title":"JS","text":"In\u00a0[2]: Copied! <pre>import ipywidgets as widgets\nfrom IPython.display import display, clear_output\n\nimport bpy\ncube = bpy.data.objects['Cube']\n\n\nwidget = widgets.FloatSlider(value=0.0, min=0.0, max=1)\n\ndisplay(widget)\n</pre> import ipywidgets as widgets from IPython.display import display, clear_output  import bpy cube = bpy.data.objects['Cube']   widget = widgets.FloatSlider(value=0.0, min=0.0, max=1)  display(widget) <pre>FloatSlider(value=0.0, max=1.0)</pre> In\u00a0[3]: Copied! <pre>cube.location.z = widget.value\n</pre> cube.location.z = widget.value In\u00a0[4]: Copied! <pre>def update_cube_translation(translation_value):\n    cube.location.z = translation_value\n    bpy.context.view_layer.update()\n\n# Function to handle slider value changes\ndef on_slider_change(change):\n    update_cube_translation(change['new'])\n\n# Observe the slider\nwidget.observe(on_slider_change, names='value')\n\n# Initial update of the cube's translation\nupdate_cube_translation(widget.value)\n</pre> def update_cube_translation(translation_value):     cube.location.z = translation_value     bpy.context.view_layer.update()  # Function to handle slider value changes def on_slider_change(change):     update_cube_translation(change['new'])  # Observe the slider widget.observe(on_slider_change, names='value')  # Initial update of the cube's translation update_cube_translation(widget.value) In\u00a0[5]: Copied! <pre># Proof of concept: Marimo notebook do not need this observe function:\n# https://github.com/iplai/marimo-blender/tree/main?tab=readme-ov-file#showcase\n#\n</pre> # Proof of concept: Marimo notebook do not need this observe function: # https://github.com/iplai/marimo-blender/tree/main?tab=readme-ov-file#showcase # In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"n4javascript/#js","title":"JS\u00b6","text":""},{"location":"n5anywidget/","title":"Anywidget","text":"In\u00a0[\u00a0]: Copied! <pre>import bpy\ncube = bpy.data.objects['Cube']\n</pre> import bpy cube = bpy.data.objects['Cube'] In\u00a0[\u00a0]: Copied! <pre>import anywidget\nimport traitlets\n\nclass CounterWidget(anywidget.AnyWidget):\n    _esm = \"\"\"\n    function render({ model, el }) {\n      let button = document.createElement(\"button\");\n      button.innerHTML = `count is ${model.get(\"value\")}`;\n      button.addEventListener(\"click\", () =&gt; {\n        model.set(\"value\", model.get(\"value\") + 1);\n        model.save_changes();\n      });\n      model.on(\"change:value\", () =&gt; {\n        button.innerHTML = `count is ${model.get(\"value\")}`;\n      });\n      el.classList.add(\"counter-widget\");\n      el.appendChild(button);\n    }\n    export default { render };\n    \"\"\"\n    _css = \"\"\"\n    .counter-widget button { color: red; font-size: 1.75rem; background-color: #ea580c; padding: 0.5rem 1rem; border: none; border-radius: 0.25rem; }\n    .counter-widget button:hover { background-color: #9a3412; }\n    \"\"\"\n    value = traitlets.Int(0).tag(sync=True)\n\nwidget = CounterWidget(value=-2)\nwidget \n</pre> import anywidget import traitlets  class CounterWidget(anywidget.AnyWidget):     _esm = \"\"\"     function render({ model, el }) {       let button = document.createElement(\"button\");       button.innerHTML = `count is ${model.get(\"value\")}`;       button.addEventListener(\"click\", () =&gt; {         model.set(\"value\", model.get(\"value\") + 1);         model.save_changes();       });       model.on(\"change:value\", () =&gt; {         button.innerHTML = `count is ${model.get(\"value\")}`;       });       el.classList.add(\"counter-widget\");       el.appendChild(button);     }     export default { render };     \"\"\"     _css = \"\"\"     .counter-widget button { color: red; font-size: 1.75rem; background-color: #ea580c; padding: 0.5rem 1rem; border: none; border-radius: 0.25rem; }     .counter-widget button:hover { background-color: #9a3412; }     \"\"\"     value = traitlets.Int(0).tag(sync=True)  widget = CounterWidget(value=-2) widget  In\u00a0[\u00a0]: Copied! <pre>widget.value\n</pre> widget.value In\u00a0[\u00a0]: Copied! <pre>def update_cube_translation(translation_value):\n    cube.location.z = translation_value\n    bpy.context.view_layer.update()\n\n# Function to handle slider value changes\ndef on_slider_change(change):\n    update_cube_translation(change['new'])\n\n# Observe the slider\nwidget.observe(on_slider_change, names='value')\n\n# Initial update of the cube's translation\nupdate_cube_translation(widget.value)\n</pre> def update_cube_translation(translation_value):     cube.location.z = translation_value     bpy.context.view_layer.update()  # Function to handle slider value changes def on_slider_change(change):     update_cube_translation(change['new'])  # Observe the slider widget.observe(on_slider_change, names='value')  # Initial update of the cube's translation update_cube_translation(widget.value) In\u00a0[\u00a0]: Copied! <pre>import bpy\ncube = bpy.data.objects['Cube']\n</pre> import bpy cube = bpy.data.objects['Cube'] In\u00a0[\u00a0]: Copied! <pre>import anywidget\nimport traitlets\n\nclass HelloWidget(anywidget.AnyWidget):\n    _esm = \"\"\"\n        import \"https://esm.sh/vanilla-colorful@0.7.2\";\n\n        function render({ model, el }) {\n        // Create the container for the color picker\n        let container = document.createElement(\"div\");\n        container.style.position = \"relative\"; \n        container.style.width = \"300px\"; \n        container.style.height = \"300px\"; \n        el.appendChild(container);\n\n        // Create the input element for the color picker\n        let colorPicker = document.createElement(\"hex-color-picker\");\n        colorPicker.color = \"#1e88e5\"; // Set the initial color\n        container.appendChild(colorPicker);\n\n        // Function to calculate brightness from RGB\n        function getBrightness(hexColor) {\n            let r = parseInt(hexColor.slice(1, 3), 16);\n            let g = parseInt(hexColor.slice(3, 5), 16);\n            let b = parseInt(hexColor.slice(5, 7), 16);\n            // Calculate brightness\n            return Math.round(0.299 * r + 0.587 * g + 0.114 * b);\n        }\n\n        // Add an event listener for color changes\n        colorPicker.addEventListener(\"color-changed\", (event) =&gt; {\n            const newColor = event.detail.value;\n            const brightness = getBrightness(newColor);  // Calculate brightness\n            model.set('brightness_value', brightness);  // Update the brightness traitlet\n            model.save_changes();\n        });\n\n        // Get current color value and initial brightness\n        const initialBrightness = getBrightness(colorPicker.color);\n        model.set('brightness_value', initialBrightness);  // Set initial brightness\n        model.save_changes();\n        }\n\n        export default { render };\n    \"\"\"\n\n    brightness_value = traitlets.Int(0).tag(sync=True)  # Initial brightness is set to 0\n\nwidget2 = HelloWidget()\nwidget2\n</pre> import anywidget import traitlets  class HelloWidget(anywidget.AnyWidget):     _esm = \"\"\"         import \"https://esm.sh/vanilla-colorful@0.7.2\";          function render({ model, el }) {         // Create the container for the color picker         let container = document.createElement(\"div\");         container.style.position = \"relative\";          container.style.width = \"300px\";          container.style.height = \"300px\";          el.appendChild(container);          // Create the input element for the color picker         let colorPicker = document.createElement(\"hex-color-picker\");         colorPicker.color = \"#1e88e5\"; // Set the initial color         container.appendChild(colorPicker);          // Function to calculate brightness from RGB         function getBrightness(hexColor) {             let r = parseInt(hexColor.slice(1, 3), 16);             let g = parseInt(hexColor.slice(3, 5), 16);             let b = parseInt(hexColor.slice(5, 7), 16);             // Calculate brightness             return Math.round(0.299 * r + 0.587 * g + 0.114 * b);         }          // Add an event listener for color changes         colorPicker.addEventListener(\"color-changed\", (event) =&gt; {             const newColor = event.detail.value;             const brightness = getBrightness(newColor);  // Calculate brightness             model.set('brightness_value', brightness);  // Update the brightness traitlet             model.save_changes();         });          // Get current color value and initial brightness         const initialBrightness = getBrightness(colorPicker.color);         model.set('brightness_value', initialBrightness);  // Set initial brightness         model.save_changes();         }          export default { render };     \"\"\"      brightness_value = traitlets.Int(0).tag(sync=True)  # Initial brightness is set to 0  widget2 = HelloWidget() widget2 In\u00a0[\u00a0]: Copied! <pre>def update_cube_translation2(translation_value):\n    cube.location.z = translation_value /100 *2\n    bpy.context.view_layer.update()\n\n# Function to handle slider value changes\ndef on_slider_change2(change):\n    update_cube_translation2(change['new'])\n\n# Observe the slider\nwidget2.observe(on_slider_change2, names='brightness_value')\n\n# Initial update of the cube's translation\nupdate_cube_translation2(widget2.brightness_value)\n</pre> def update_cube_translation2(translation_value):     cube.location.z = translation_value /100 *2     bpy.context.view_layer.update()  # Function to handle slider value changes def on_slider_change2(change):     update_cube_translation2(change['new'])  # Observe the slider widget2.observe(on_slider_change2, names='brightness_value')  # Initial update of the cube's translation update_cube_translation2(widget2.brightness_value) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"n5anywidget/#anywidget","title":"Anywidget\u00b6","text":"<p>https://anywidget.dev/en/getting-started/</p>"},{"location":"render_utils/","title":"Render utils","text":"In\u00a0[\u00a0]: Copied! <pre>import bpy\nfrom IPython.display import Image, display\nfrom mathutils import Vector\nfrom pathlib import Path\nfrom typst_importer.curve_utils import get_curve_collection_bounds\nimport tempfile\n</pre> import bpy from IPython.display import Image, display from mathutils import Vector from pathlib import Path from typst_importer.curve_utils import get_curve_collection_bounds import tempfile In\u00a0[\u00a0]: Copied! <pre>def fresh_scene(keep_cube=False):\n    bpy.ops.object.select_all(action='DESELECT')\n    # Keep only Plane, Camera and Sun\n    for obj in bpy.context.scene.objects:\n        if obj.name not in ['Plane', 'Camera', 'Sun']:\n            obj.select_set(True)\n    bpy.ops.object.delete()\n    for collection in bpy.data.collections:\n        if collection.name != \"Collection\":\n            bpy.data.collections.remove(collection)\n</pre> def fresh_scene(keep_cube=False):     bpy.ops.object.select_all(action='DESELECT')     # Keep only Plane, Camera and Sun     for obj in bpy.context.scene.objects:         if obj.name not in ['Plane', 'Camera', 'Sun']:             obj.select_set(True)     bpy.ops.object.delete()     for collection in bpy.data.collections:         if collection.name != \"Collection\":             bpy.data.collections.remove(collection) In\u00a0[\u00a0]: Copied! <pre>def adjust_camera_to_collection(c, padding_factor=-0.2):\n    min_p, max_p = get_curve_collection_bounds(c)\n    center = (min_p + max_p) / 2\n    size = max_p - min_p\n    padded_size = size * (1 + padding_factor)\n    padded_max_dim = max(padded_size.x, padded_size.y, padded_size.z)\n\n    if 'Camera' not in bpy.data.objects:\n        bpy.ops.object.camera_add()\n        camera = bpy.data.objects['Camera']\n    else:\n        camera = bpy.data.objects['Camera']\n    \n    bpy.context.scene.camera = camera\n    camera.location = (center.x, center.y, center.z + padded_max_dim*2)\n    camera.rotation_euler = (0, 0, 0)\n    camera.data.type = 'ORTHO'\n    camera.data.ortho_scale = padded_max_dim * 2\n    aspect_ratio = padded_size.x / padded_size.y\n    bpy.context.scene.render.resolution_x = 960\n    bpy.context.scene.render.resolution_y = int(960 / aspect_ratio)\n</pre> def adjust_camera_to_collection(c, padding_factor=-0.2):     min_p, max_p = get_curve_collection_bounds(c)     center = (min_p + max_p) / 2     size = max_p - min_p     padded_size = size * (1 + padding_factor)     padded_max_dim = max(padded_size.x, padded_size.y, padded_size.z)      if 'Camera' not in bpy.data.objects:         bpy.ops.object.camera_add()         camera = bpy.data.objects['Camera']     else:         camera = bpy.data.objects['Camera']          bpy.context.scene.camera = camera     camera.location = (center.x, center.y, center.z + padded_max_dim*2)     camera.rotation_euler = (0, 0, 0)     camera.data.type = 'ORTHO'     camera.data.ortho_scale = padded_max_dim * 2     aspect_ratio = padded_size.x / padded_size.y     bpy.context.scene.render.resolution_x = 960     bpy.context.scene.render.resolution_y = int(960 / aspect_ratio) In\u00a0[\u00a0]: Copied! <pre>def render_result(width=\"300pt\", collection=None, padding_factor=-0.2):\n    if collection is not None:\n        adjust_camera_to_collection(collection, padding_factor)\n        \n    with tempfile.TemporaryDirectory() as tmpdir:\n        output_path = str(Path(tmpdir) / 'img.png')\n        bpy.ops.render.render()\n        bpy.data.images['Render Result'].save_render(filepath=output_path)\n        display(Image(filename=output_path, width=width, height=\"auto\"))\n</pre> def render_result(width=\"300pt\", collection=None, padding_factor=-0.2):     if collection is not None:         adjust_camera_to_collection(collection, padding_factor)              with tempfile.TemporaryDirectory() as tmpdir:         output_path = str(Path(tmpdir) / 'img.png')         bpy.ops.render.render()         bpy.data.images['Render Result'].save_render(filepath=output_path)         display(Image(filename=output_path, width=width, height=\"auto\")) In\u00a0[\u00a0]: Copied! <pre>def load_paper_background():\n    path = Path.home() / \"projects/bpy-gallery/docs/paper_background.blend\"\n    filepath = str(path)\n    \n    with bpy.data.libraries.load(filepath, link=False) as (data_from, data_to):\n        data_to.objects = data_from.objects\n\n    for obj in data_to.objects:\n        if obj is not None:\n            bpy.context.collection.objects.link(obj)\n</pre> def load_paper_background():     path = Path.home() / \"projects/bpy-gallery/docs/paper_background.blend\"     filepath = str(path)          with bpy.data.libraries.load(filepath, link=False) as (data_from, data_to):         data_to.objects = data_from.objects      for obj in data_to.objects:         if obj is not None:             bpy.context.collection.objects.link(obj)"}]}