{"config":{"lang":["en"],"separator":"[\\s\\-_,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bpy Gallery","text":"<p>Welcome to this Documentation, where you'll find curated examples on how to use Blender with python notebooks. If you find these resources useful, you're welcome to give a \u2b50 a on GitHub : https://github.com/kolibril13/ipyblender-experimental You can also support my work by buying me a coffe:</p>"},{"location":"n1objects/","title":"Adding Objects","text":"In\u00a0[1]: Copied! <pre>import bpy\nfrom IPython.display import display, Image\n\ndef fresh_scene(keep_cube=False):\n    # Deselect all objects\n    bpy.ops.object.select_all(action='DESELECT')\n    \n    # Select all objects except cameras and optionally the default cube\n    for obj in bpy.context.scene.objects:\n        if obj.type == 'CAMERA':\n            obj.select_set(False)\n        elif obj.name == 'Cube' and keep_cube:\n            obj.select_set(False)\n        else:\n            obj.select_set(True)\n    \n    bpy.ops.object.delete()\n    \n    # Add light\n    bpy.ops.object.light_add(type='SUN')\n    sun = bpy.context.object\n\n    sun.location = (0, 0, 0)\n    from math import radians\n    sun.rotation_euler = (radians(204), radians(-133), radians(-67))\n    sun.data.energy = 5  \n\n\ndef render_result():\n    bpy.ops.render.render()\n    bpy.data.images['Render Result'].save_render(filepath=\"img.png\")\n    display(Image(filename=\"img.png\"))\n\nbpy.context.scene.render.resolution_x = 500\nbpy.context.scene.render.resolution_y = 200\n</pre> import bpy from IPython.display import display, Image  def fresh_scene(keep_cube=False):     # Deselect all objects     bpy.ops.object.select_all(action='DESELECT')          # Select all objects except cameras and optionally the default cube     for obj in bpy.context.scene.objects:         if obj.type == 'CAMERA':             obj.select_set(False)         elif obj.name == 'Cube' and keep_cube:             obj.select_set(False)         else:             obj.select_set(True)          bpy.ops.object.delete()          # Add light     bpy.ops.object.light_add(type='SUN')     sun = bpy.context.object      sun.location = (0, 0, 0)     from math import radians     sun.rotation_euler = (radians(204), radians(-133), radians(-67))     sun.data.energy = 5     def render_result():     bpy.ops.render.render()     bpy.data.images['Render Result'].save_render(filepath=\"img.png\")     display(Image(filename=\"img.png\"))  bpy.context.scene.render.resolution_x = 500 bpy.context.scene.render.resolution_y = 200 In\u00a0[3]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_monkey_add(size=2.5, location=(0, 0, 0))\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_monkey_add(size=2.5, location=(0, 0, 0)) render_result() In\u00a0[4]: Copied! <pre>fresh_scene()\nbpy.ops.object.gpencil_add(location=(0, 0, 0), type='STROKE')\ngpencil_object = bpy.context.active_object\ngpencil_object.scale = (3, 3, 3)\n\nrender_result()\n</pre> fresh_scene() bpy.ops.object.gpencil_add(location=(0, 0, 0), type='STROKE') gpencil_object = bpy.context.active_object gpencil_object.scale = (3, 3, 3)  render_result() In\u00a0[5]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, location=(0, 0, 0))  render_result() In\u00a0[6]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cone_add(radius1=1, depth=2, location=(0, 0, 0))  \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cone_add(radius1=1, depth=2, location=(0, 0, 0))   render_result() In\u00a0[7]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(0, 0, 0))  render_result() In\u00a0[8]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_torus_add(major_radius=2, minor_radius=0.3, location=(0,0, 0))\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_torus_add(major_radius=2, minor_radius=0.3, location=(0,0, 0)) render_result() In\u00a0[9]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_ico_sphere_add(radius=1, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_ico_sphere_add(radius=1, location=(0, 0, 0))  render_result() In\u00a0[10]: Copied! <pre>fresh_scene()\nbpy.ops.object.text_add(location=(-4, 0, 0))\nbpy.context.object.data.body = \"Hello \ud83d\ude04\"\nbpy.context.object.scale = (2, 2, 2)\nrender_result()\n</pre> fresh_scene() bpy.ops.object.text_add(location=(-4, 0, 0)) bpy.context.object.data.body = \"Hello \ud83d\ude04\" bpy.context.object.scale = (2, 2, 2) render_result() In\u00a0[11]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_plane_add(size=3, location=(0, 0, 0))  \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_plane_add(size=3, location=(0, 0, 0))   render_result() In\u00a0[12]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_circle_add(radius=2.5, location=(0, 0, 0), fill_type='NGON')\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_circle_add(radius=2.5, location=(0, 0, 0), fill_type='NGON') render_result() In\u00a0[13]: Copied! <pre>fresh_scene()\nbpy.ops.object.empty_add(type='PLAIN_AXES', location=(4, 0, 0)) # (This is not shown in the image, but it is there :) )\nrender_result()\n</pre> fresh_scene() bpy.ops.object.empty_add(type='PLAIN_AXES', location=(4, 0, 0)) # (This is not shown in the image, but it is there :) ) render_result() In\u00a0[14]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))  render_result() In\u00a0[15]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) \nlight = bpy.data.objects.new(\"Light\", bpy.data.lights.new(\"Light\", 'POINT'))\nlight.location = (3, 0, 2)\nlight.data.energy = 8000\nbpy.context.collection.objects.link(light)\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))  light = bpy.data.objects.new(\"Light\", bpy.data.lights.new(\"Light\", 'POINT')) light.location = (3, 0, 2) light.data.energy = 8000 bpy.context.collection.objects.link(light) render_result() In\u00a0[16]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) \ncube = bpy.context.active_object\nbevel_modifier = cube.modifiers.new(name=\"Bevel\", type='BEVEL')\nbevel_modifier.width = 0.3  # Adjust the bevel width\nbevel_modifier.segments = 5  # Number of segments for a smoother bevel\n\n# Optionally apply the modifier if needed (not necessary for visualization)\n# bpy.ops.object.modifier_apply(modifier=\"Bevel\")\n\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))  cube = bpy.context.active_object bevel_modifier = cube.modifiers.new(name=\"Bevel\", type='BEVEL') bevel_modifier.width = 0.3  # Adjust the bevel width bevel_modifier.segments = 5  # Number of segments for a smoother bevel  # Optionally apply the modifier if needed (not necessary for visualization) # bpy.ops.object.modifier_apply(modifier=\"Bevel\")  render_result() In\u00a0[17]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create the subdivision surface modifier and change it to 'SIMPLE'\nsubsurf_modifier = cube.modifiers.new(name=\"Subdivision\", type='SUBSURF')\nsubsurf_modifier.subdivision_type = 'SIMPLE'  # Change to 'SIMPLE' instead of 'CATMULL_CLARK'\nsubsurf_modifier.levels = 4  # Viewport subdivision level\nsubsurf_modifier.render_levels = 4  # Render subdivision level\n\ndisplace_modifier = cube.modifiers.new(name=\"Displace\", type='DISPLACE')\ndisplace_modifier.strength = 0.5  # Adjust the displacement strength\n\ntexture = bpy.data.textures.new(\"DisplaceTexture\", type='CLOUDS')\ntexture.noise_scale = 1  # Reduce the noise scale to make it more detailed\ndisplace_modifier.texture = texture  # Assign the texture to the modifier\n\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create the subdivision surface modifier and change it to 'SIMPLE' subsurf_modifier = cube.modifiers.new(name=\"Subdivision\", type='SUBSURF') subsurf_modifier.subdivision_type = 'SIMPLE'  # Change to 'SIMPLE' instead of 'CATMULL_CLARK' subsurf_modifier.levels = 4  # Viewport subdivision level subsurf_modifier.render_levels = 4  # Render subdivision level  displace_modifier = cube.modifiers.new(name=\"Displace\", type='DISPLACE') displace_modifier.strength = 0.5  # Adjust the displacement strength  texture = bpy.data.textures.new(\"DisplaceTexture\", type='CLOUDS') texture.noise_scale = 1  # Reduce the noise scale to make it more detailed displace_modifier.texture = texture  # Assign the texture to the modifier  render_result() In\u00a0[18]: Copied! <pre># current blender version\nbpy.app.version_string\n</pre> # current blender version bpy.app.version_string Out[18]: <pre>'4.2.3 LTS'</pre> In\u00a0[19]: Copied! <pre># current blender version\nbpy.context.scene.render.engine\n</pre> # current blender version bpy.context.scene.render.engine Out[19]: <pre>'BLENDER_EEVEE_NEXT'</pre> In\u00a0[20]: Copied! <pre>bpy.context.scene.render.resolution_x, bpy.context.scene.render.resolution_y\n</pre> bpy.context.scene.render.resolution_x, bpy.context.scene.render.resolution_y Out[20]: <pre>(500, 200)</pre> In\u00a0[21]: Copied! <pre>bpy.context.scene.name\n</pre> bpy.context.scene.name Out[21]: <pre>'Scene'</pre> In\u00a0[22]: Copied! <pre>bpy.context.active_object.name\n</pre> bpy.context.active_object.name Out[22]: <pre>'Cube'</pre> In\u00a0[23]: Copied! <pre>bpy.context.active_object.location\n</pre> bpy.context.active_object.location Out[23]: <pre>Vector((0.0, 0.0, 0.0))</pre> In\u00a0[24]: Copied! <pre>bpy.context.collection.objects.keys()\n</pre> bpy.context.collection.objects.keys() Out[24]: <pre>['Camera', 'Sun', 'Cube']</pre> In\u00a0[25]: Copied! <pre>bpy.context.collection.objects.values()\n</pre> bpy.context.collection.objects.values() Out[25]: <pre>[bpy.data.objects['Camera'], bpy.data.objects['Sun'], bpy.data.objects['Cube']]</pre> In\u00a0[26]: Copied! <pre>fresh_scene()\n\n# Add a cube\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create and assign a green material to the cube without using nodes\nmat = bpy.data.materials.new(name=\"GreenMaterial\")\nmat.diffuse_color = (0, 1, 0, 1)  # Green color (R, G, B, A)\n\n# Apply material to the cube\ncube.data.materials.clear()  # Clear any existing materials\ncube.data.materials.append(mat)\n\nrender_result()\n</pre> fresh_scene()  # Add a cube bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create and assign a green material to the cube without using nodes mat = bpy.data.materials.new(name=\"GreenMaterial\") mat.diffuse_color = (0, 1, 0, 1)  # Green color (R, G, B, A)  # Apply material to the cube cube.data.materials.clear()  # Clear any existing materials cube.data.materials.append(mat)  render_result() In\u00a0[27]: Copied! <pre>fresh_scene()\n\n# colors with nodes\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create and assign a blue material to the cube\nmat = bpy.data.materials.new(name=\"BlueMaterial\")\nmat.use_nodes = True\nbsdf = mat.node_tree.nodes.get('Principled BSDF')\nbsdf.inputs['Base Color'].default_value = (0, 0, 1, 1)  # Blue color (R, G, B, A)\n\n# Apply material to the cube\ncube.data.materials.clear()  # Clear any existing materials\ncube.data.materials.append(mat)\nrender_result()\n</pre> fresh_scene()  # colors with nodes  bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create and assign a blue material to the cube mat = bpy.data.materials.new(name=\"BlueMaterial\") mat.use_nodes = True bsdf = mat.node_tree.nodes.get('Principled BSDF') bsdf.inputs['Base Color'].default_value = (0, 0, 1, 1)  # Blue color (R, G, B, A)  # Apply material to the cube cube.data.materials.clear()  # Clear any existing materials cube.data.materials.append(mat) render_result() In\u00a0[28]: Copied! <pre>fresh_scene()\n\nbpy.ops.mesh.primitive_plane_add(size=6, location=(0, 0, 0))\nplane = bpy.context.object\n\nmaterial = bpy.data.materials.new(name=\"ImageMaterial\")\nmaterial.use_nodes = True\nbsdf = material.node_tree.nodes[\"Principled BSDF\"]\n\ntex_image = material.node_tree.nodes.new('ShaderNodeTexImage')\ntex_image.image = bpy.data.images.load(\"cute_dog.jpg\")\n\nmaterial.node_tree.links.new(bsdf.inputs['Base Color'], tex_image.outputs['Color'])\nplane.data.materials.append(material)\n\nrender_result()\n</pre> fresh_scene()  bpy.ops.mesh.primitive_plane_add(size=6, location=(0, 0, 0)) plane = bpy.context.object  material = bpy.data.materials.new(name=\"ImageMaterial\") material.use_nodes = True bsdf = material.node_tree.nodes[\"Principled BSDF\"]  tex_image = material.node_tree.nodes.new('ShaderNodeTexImage') tex_image.image = bpy.data.images.load(\"cute_dog.jpg\")  material.node_tree.links.new(bsdf.inputs['Base Color'], tex_image.outputs['Color']) plane.data.materials.append(material)  render_result() In\u00a0[29]: Copied! <pre>fresh_scene()\n\n# Working with shader nodes is possible, but get's quite involved quite quickly\n\n# Add a cube\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create a new material for the cube\nmaterial = bpy.data.materials.new(name=\"YellowToOrangeGradient\")\nmaterial.use_nodes = True\nnodes = material.node_tree.nodes\n\n# Clear default nodes\nfor node in nodes:\n    nodes.remove(node)\n\n# Add a Gradient Texture\ngradient = nodes.new(type=\"ShaderNodeTexGradient\")\ngradient.gradient_type = \"LINEAR\"\ngradient.location = (0, 0)\n\n# Add a Color Ramp to control the gradient colors\nramp = nodes.new(type=\"ShaderNodeValToRGB\")\nramp.color_ramp.interpolation = \"LINEAR\"\nramp.location = (300, 0)\n\nramp.color_ramp.elements[0].color = (1, 1, 0, 1)  # Yellow (R, G, B, A)\nramp.color_ramp.elements[1].color = (1, 0.3, 0, 1)  # Orange (R, G, B, A)\n\n# Add the Principled BSDF shader\nbsdf = nodes.new(type=\"ShaderNodeBsdfPrincipled\")\nbsdf.location = (600, 0)\n\n# Create the output node\noutput = nodes.new(type=\"ShaderNodeOutputMaterial\")\noutput.location = (900, 0)\n\n# Link the nodes together\nlinks = material.node_tree.links\nlinks.new(gradient.outputs[\"Color\"], ramp.inputs[0])\nlinks.new(ramp.outputs[\"Color\"], bsdf.inputs[\"Base Color\"])\nlinks.new(bsdf.outputs[\"BSDF\"], output.inputs[\"Surface\"])\n\n# Apply the material to the cube\ncube.data.materials.clear()  # Clear any existing materials\ncube.data.materials.append(material)\n\nrender_result()\n</pre> fresh_scene()  # Working with shader nodes is possible, but get's quite involved quite quickly  # Add a cube bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create a new material for the cube material = bpy.data.materials.new(name=\"YellowToOrangeGradient\") material.use_nodes = True nodes = material.node_tree.nodes  # Clear default nodes for node in nodes:     nodes.remove(node)  # Add a Gradient Texture gradient = nodes.new(type=\"ShaderNodeTexGradient\") gradient.gradient_type = \"LINEAR\" gradient.location = (0, 0)  # Add a Color Ramp to control the gradient colors ramp = nodes.new(type=\"ShaderNodeValToRGB\") ramp.color_ramp.interpolation = \"LINEAR\" ramp.location = (300, 0)  ramp.color_ramp.elements[0].color = (1, 1, 0, 1)  # Yellow (R, G, B, A) ramp.color_ramp.elements[1].color = (1, 0.3, 0, 1)  # Orange (R, G, B, A)  # Add the Principled BSDF shader bsdf = nodes.new(type=\"ShaderNodeBsdfPrincipled\") bsdf.location = (600, 0)  # Create the output node output = nodes.new(type=\"ShaderNodeOutputMaterial\") output.location = (900, 0)  # Link the nodes together links = material.node_tree.links links.new(gradient.outputs[\"Color\"], ramp.inputs[0]) links.new(ramp.outputs[\"Color\"], bsdf.inputs[\"Base Color\"]) links.new(bsdf.outputs[\"BSDF\"], output.inputs[\"Surface\"])  # Apply the material to the cube cube.data.materials.clear()  # Clear any existing materials cube.data.materials.append(material)  render_result() In\u00a0[32]: Copied! <pre>fresh_scene()\n\n# Setting up geonodes is possible, but get's quite involved quite quickly\n\n# Add a cube\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Setup geometry nodes\ngeo_nodes = cube.modifiers.new(name=\"GeometryNodes\", type=\"NODES\")\nnode_group = bpy.data.node_groups.new(\"GeometryNodes\", \"GeometryNodeTree\")\ngeo_nodes.node_group = node_group\n\n# Create input/output and transformation nodes\ninNode = node_group.nodes.new(\"NodeGroupInput\")\ninNode.location = (0, 0)\n\ntransformNode = node_group.nodes.new(\"GeometryNodeTransform\")\ntransformNode.location = (300, 0)\ntransformNode.inputs[\"Scale\"].default_value = (3, 2, 1)\n\noutNode = node_group.nodes.new(\"NodeGroupOutput\")\noutNode.location = (600, 0)\n\n# Define geometry input/output sockets\nnode_group.interface.new_socket(name=\"Geometry\", in_out=\"INPUT\", socket_type=\"NodeSocketGeometry\")\nnode_group.interface.new_socket(name=\"Geometry\", in_out=\"OUTPUT\", socket_type=\"NodeSocketGeometry\")\n\n# Link the nodes together\nnode_group.links.new(inNode.outputs[\"Geometry\"], transformNode.inputs[\"Geometry\"])\nnode_group.links.new(transformNode.outputs[\"Geometry\"], outNode.inputs[\"Geometry\"])\n\nrender_result()\n</pre> fresh_scene()  # Setting up geonodes is possible, but get's quite involved quite quickly  # Add a cube bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Setup geometry nodes geo_nodes = cube.modifiers.new(name=\"GeometryNodes\", type=\"NODES\") node_group = bpy.data.node_groups.new(\"GeometryNodes\", \"GeometryNodeTree\") geo_nodes.node_group = node_group  # Create input/output and transformation nodes inNode = node_group.nodes.new(\"NodeGroupInput\") inNode.location = (0, 0)  transformNode = node_group.nodes.new(\"GeometryNodeTransform\") transformNode.location = (300, 0) transformNode.inputs[\"Scale\"].default_value = (3, 2, 1)  outNode = node_group.nodes.new(\"NodeGroupOutput\") outNode.location = (600, 0)  # Define geometry input/output sockets node_group.interface.new_socket(name=\"Geometry\", in_out=\"INPUT\", socket_type=\"NodeSocketGeometry\") node_group.interface.new_socket(name=\"Geometry\", in_out=\"OUTPUT\", socket_type=\"NodeSocketGeometry\")  # Link the nodes together node_group.links.new(inNode.outputs[\"Geometry\"], transformNode.inputs[\"Geometry\"]) node_group.links.new(transformNode.outputs[\"Geometry\"], outNode.inputs[\"Geometry\"])  render_result() In\u00a0[33]: Copied! <pre>bpy.ops.wm.save_as_mainfile(filepath=\"scene.blend\")\n</pre> bpy.ops.wm.save_as_mainfile(filepath=\"scene.blend\") <pre>Info: Total files 1 | Changed 1 | Failed 0\nInfo: Saved \"scene.blend\"\n</pre> Out[33]: <pre>{'FINISHED'}</pre> In\u00a0[34]: Copied! <pre>fresh_scene()\nbpy.ops.wm.open_mainfile(filepath=\"donut.blend\")\n</pre> fresh_scene() bpy.ops.wm.open_mainfile(filepath=\"donut.blend\") Out[34]: <pre>{'FINISHED'}</pre> In\u00a0[35]: Copied! <pre>bpy.context.scene.render.engine = \"BLENDER_WORKBENCH\"\nbpy.context.scene.render.resolution_x = 500\nbpy.context.scene.render.resolution_y = 200\n\nrender_result()\n</pre> bpy.context.scene.render.engine = \"BLENDER_WORKBENCH\" bpy.context.scene.render.resolution_x = 500 bpy.context.scene.render.resolution_y = 200  render_result() In\u00a0[36]: Copied! <pre>bpy.context.scene.render.engine = \"BLENDER_EEVEE_NEXT\"\nrender_result()\n</pre> bpy.context.scene.render.engine = \"BLENDER_EEVEE_NEXT\" render_result() In\u00a0[37]: Copied! <pre>bpy.context.scene.render.engine = \"CYCLES\"\nbpy.context.scene.cycles.samples = 10\nrender_result()\n</pre> bpy.context.scene.render.engine = \"CYCLES\" bpy.context.scene.cycles.samples = 10 render_result() In\u00a0[38]: Copied! <pre># optional: suppress text output (I did not find a better way yet)\nimport sys \nimport os\n\nsys.stdout = open(os.devnull, 'w')\nsys.stderr = open(os.devnull, 'w')\n</pre> # optional: suppress text output (I did not find a better way yet) import sys  import os  sys.stdout = open(os.devnull, 'w') sys.stderr = open(os.devnull, 'w')  In\u00a0[39]: Copied! <pre>bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 0.1\nbpy.context.object.data.update()\nrender_result()\n</pre> bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 0.1 bpy.context.object.data.update() render_result() In\u00a0[40]: Copied! <pre>bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 2\nbpy.context.object.data.update()\nrender_result()\n</pre> bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 2 bpy.context.object.data.update() render_result() In\u00a0[41]: Copied! <pre>bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 10\nbpy.context.object.data.update()\nrender_result()\n</pre> bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 10 bpy.context.object.data.update() render_result() In\u00a0[44]: Copied! <pre>bpy.data.materials[\"Material.001\"].node_tree.nodes[\"Principled BSDF\"].inputs[0].default_value = (0, 0.1, 0, 1)\nrender_result()\n</pre> bpy.data.materials[\"Material.001\"].node_tree.nodes[\"Principled BSDF\"].inputs[0].default_value = (0, 0.1, 0, 1) render_result() In\u00a0[47]: Copied! <pre>bpy.data.materials[\"Material.001\"].node_tree.nodes[\"Principled BSDF\"].inputs[0].default_value = (0, 0, 0.1, 1)\nrender_result()\n</pre> bpy.data.materials[\"Material.001\"].node_tree.nodes[\"Principled BSDF\"].inputs[0].default_value = (0, 0, 0.1, 1) render_result() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"n1objects/#adding-objects","title":"Adding Objects\u00b6","text":""},{"location":"n1objects/#applying-modifiers","title":"Applying Modifiers\u00b6","text":""},{"location":"n1objects/#settings","title":"Settings\u00b6","text":""},{"location":"n1objects/#using-colors","title":"Using colors\u00b6","text":""},{"location":"n1objects/#setting-up-shaders","title":"Setting Up Shaders\u00b6","text":"<p>Here's an example to generate the following shader tree  It's quite a lot of code, so I would recommend to better set up nodes in the GUI.</p>"},{"location":"n1objects/#setting-up-geometry-nodes","title":"Setting up Geometry Nodes\u00b6","text":""},{"location":"n1objects/#save-file","title":"Save File\u00b6","text":"<p>You can any time also save your Blender file like this:</p>"},{"location":"n1objects/#load-file","title":"Load file\u00b6","text":""},{"location":"n1objects/#choose-render-engine","title":"Choose render engine\u00b6","text":""},{"location":"n1objects/#manipulate-geometry-nodes","title":"Manipulate geometry nodes\u00b6","text":""},{"location":"n1objects/#manipulating-shaders","title":"Manipulating shaders\u00b6","text":""},{"location":"n2data_simple/","title":"Simple data","text":"In\u00a0[\u00a0]: Copied! <pre>import bpy\nfrom IPython.display import display, Image\n\ndef fresh_scene(keep_cube=False):\n    # Deselect all objects\n    bpy.ops.object.select_all(action='DESELECT')\n    \n    # Select all objects except cameras and optionally the default cube\n    for obj in bpy.context.scene.objects:\n        if obj.type == 'CAMERA':\n            obj.select_set(False)\n        elif obj.name == 'Cube' and keep_cube:\n            obj.select_set(False)\n        else:\n            obj.select_set(True)\n    \n    bpy.ops.object.delete()\n    \n    # Add light\n    bpy.ops.object.light_add(type='SUN')\n    sun = bpy.context.object\n\n    sun.location = (0, 0, 0)\n    from math import radians\n    sun.rotation_euler = (radians(204), radians(-133), radians(-67))\n    sun.data.energy = 5  \n\ndef render_result():\n    bpy.ops.render.render()\n    bpy.data.images['Render Result'].save_render(filepath=\"img.png\")\n    display(Image(filename=\"img.png\"))\n\nbpy.context.scene.render.resolution_x = 500\nbpy.context.scene.render.resolution_y = 200\n</pre> import bpy from IPython.display import display, Image  def fresh_scene(keep_cube=False):     # Deselect all objects     bpy.ops.object.select_all(action='DESELECT')          # Select all objects except cameras and optionally the default cube     for obj in bpy.context.scene.objects:         if obj.type == 'CAMERA':             obj.select_set(False)         elif obj.name == 'Cube' and keep_cube:             obj.select_set(False)         else:             obj.select_set(True)          bpy.ops.object.delete()          # Add light     bpy.ops.object.light_add(type='SUN')     sun = bpy.context.object      sun.location = (0, 0, 0)     from math import radians     sun.rotation_euler = (radians(204), radians(-133), radians(-67))     sun.data.energy = 5    def render_result():     bpy.ops.render.render()     bpy.data.images['Render Result'].save_render(filepath=\"img.png\")     display(Image(filename=\"img.png\"))  bpy.context.scene.render.resolution_x = 500 bpy.context.scene.render.resolution_y = 200 In\u00a0[2]: Copied! <pre>import pandas as pd\nurl = 'https://raw.githubusercontent.com/kolibril13/ipydrop/refs/heads/main/dino.csv'\ndf = pd.read_csv(url)\nlength_data = len(df)\nprint(f\"Loaded {length_data} rows\")\ndf.head()\n</pre> import pandas as pd url = 'https://raw.githubusercontent.com/kolibril13/ipydrop/refs/heads/main/dino.csv' df = pd.read_csv(url) length_data = len(df) print(f\"Loaded {length_data} rows\") df.head() <pre>Loaded 142 rows\n</pre> Out[2]: x y 0 55.3846 97.1795 1 51.5385 96.0256 2 46.1538 94.4872 3 42.8205 91.4103 4 40.7692 88.3333 In\u00a0[3]: Copied! <pre>import matplotlib.pyplot as plt\nplt.style.use('_mpl-gallery')\n</pre> import matplotlib.pyplot as plt plt.style.use('_mpl-gallery') In\u00a0[4]: Copied! <pre># Extract x and y from the DataFrame\nx_values = df['x'] / 10 \ny_values = df['y'] / 10 * 0.8\n\n# Create the scatter plot using plt.scatter\nplt.axis('equal');\nplt.scatter(x_values, y_values);\n</pre> # Extract x and y from the DataFrame x_values = df['x'] / 10  y_values = df['y'] / 10 * 0.8  # Create the scatter plot using plt.scatter plt.axis('equal'); plt.scatter(x_values, y_values); In\u00a0[5]: Copied! <pre>def camera_from_above():\n    camera = bpy.context.scene.camera\n    camera.location = (6, 4, 10)  # Position above the XY plane\n    camera.rotation_euler = (0, 0, 0)  # Rotate to look at XY plane\n    # Set the camera to orthographic mode\n    camera.data.type = 'ORTHO'\n    # Set the orthographic scale to 12\n    camera.data.ortho_scale = 9\n\n    bpy.context.scene.render.resolution_x = 300\n    bpy.context.scene.render.resolution_y = 300\n</pre> def camera_from_above():     camera = bpy.context.scene.camera     camera.location = (6, 4, 10)  # Position above the XY plane     camera.rotation_euler = (0, 0, 0)  # Rotate to look at XY plane     # Set the camera to orthographic mode     camera.data.type = 'ORTHO'     # Set the orthographic scale to 12     camera.data.ortho_scale = 9      bpy.context.scene.render.resolution_x = 300     bpy.context.scene.render.resolution_y = 300 In\u00a0[6]: Copied! <pre>fresh_scene()\n\nfor (x, y) in zip(x_values,y_values):    \n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.2, location=(x, y, 0))\n\ncamera_from_above()\nrender_result()\n</pre> fresh_scene()  for (x, y) in zip(x_values,y_values):         bpy.ops.mesh.primitive_uv_sphere_add(radius=0.2, location=(x, y, 0))  camera_from_above() render_result() In\u00a0[7]: Copied! <pre>fresh_scene()\n\nmat = bpy.data.materials.new(name=\"GreenMaterial\")\nmat.diffuse_color = (0, 0, 1, 1)  # Green color (R, G, B, A)\n\nfor (x, y) in zip(x_values,y_values):    \n    bpy.ops.mesh.primitive_uv_sphere_add(radius=0.2, location=(x, y, 0))\n    bpy.context.active_object.data.materials.append(mat)\n\nbpy.context.scene.render.resolution_x = 300\nbpy.context.scene.render.resolution_y = 300\n\n# Add a white plane behind the spheres\nbpy.ops.mesh.primitive_plane_add(size=20, location=(5, 5, 0))  \nplane = bpy.context.active_object\n\n# Create a white material and assign it to the plane\nwhite_mat = bpy.data.materials.new(name=\"WhiteMaterial\")\nwhite_mat.diffuse_color = (1, 1, 1, 1)  # White color (R, G, B, A)\nplane.data.materials.append(white_mat)\n\nrender_result()\n</pre> fresh_scene()  mat = bpy.data.materials.new(name=\"GreenMaterial\") mat.diffuse_color = (0, 0, 1, 1)  # Green color (R, G, B, A)  for (x, y) in zip(x_values,y_values):         bpy.ops.mesh.primitive_uv_sphere_add(radius=0.2, location=(x, y, 0))     bpy.context.active_object.data.materials.append(mat)  bpy.context.scene.render.resolution_x = 300 bpy.context.scene.render.resolution_y = 300  # Add a white plane behind the spheres bpy.ops.mesh.primitive_plane_add(size=20, location=(5, 5, 0))   plane = bpy.context.active_object  # Create a white material and assign it to the plane white_mat = bpy.data.materials.new(name=\"WhiteMaterial\") white_mat.diffuse_color = (1, 1, 1, 1)  # White color (R, G, B, A) plane.data.materials.append(white_mat)  render_result() <p>this works, but it's very limited! E.g.</p> <ul> <li>not possible to scale individual spheres.</li> <li>not possible to use geometry nodes with this object.</li> </ul> <p>Can we maybe add this geometry nodes setup?</p> In\u00a0[8]: Copied! <pre># option 1: Load the node group to the current blend scene\nimport bpy\n\n# Path to the blend file\nblend_file_path = \"cube_gn_position.blend\"\nnode_group_name = \"gn_place_spheres\"\n\n# Load only the node group from the blend file\nwith bpy.data.libraries.load(blend_file_path, link=False) as (data_from, data_to):\n    if node_group_name in data_from.node_groups:\n        data_to.node_groups = [node_group_name]\n\n# Access the node group\nnode_group_place_spheres = bpy.data.node_groups[node_group_name]\n\n# Print all the node names inside the node group\nprint(f\"Nodes in node group '{node_group_name}':\")\nfor node in node_group_place_spheres.nodes:\n    print(node.name)\n</pre> # option 1: Load the node group to the current blend scene import bpy  # Path to the blend file blend_file_path = \"cube_gn_position.blend\" node_group_name = \"gn_place_spheres\"  # Load only the node group from the blend file with bpy.data.libraries.load(blend_file_path, link=False) as (data_from, data_to):     if node_group_name in data_from.node_groups:         data_to.node_groups = [node_group_name]  # Access the node group node_group_place_spheres = bpy.data.node_groups[node_group_name]  # Print all the node names inside the node group print(f\"Nodes in node group '{node_group_name}':\") for node in node_group_place_spheres.nodes:     print(node.name) <pre>Nodes in node group 'gn_place_spheres':\nGroup Input\nGroup Output\nInstance on Points\nUV Sphere\n</pre> In\u00a0[9]: Copied! <pre># option 2: Open the compeletely new blend file and access the node group\nbpy.ops.wm.open_mainfile(filepath=\"cube_gn_position.blend\")\n\n# Access the node group\nnode_group_place_spheres = bpy.data.node_groups[\"gn_place_spheres\"]\n\n# Print all the node names inside the node group\nprint(\"Nodes in node group 'gn_place_spheres':\")\nfor node in node_group_place_spheres.nodes:\n    print(node.name)\n</pre> # option 2: Open the compeletely new blend file and access the node group bpy.ops.wm.open_mainfile(filepath=\"cube_gn_position.blend\")  # Access the node group node_group_place_spheres = bpy.data.node_groups[\"gn_place_spheres\"]  # Print all the node names inside the node group print(\"Nodes in node group 'gn_place_spheres':\") for node in node_group_place_spheres.nodes:     print(node.name) <pre>Nodes in node group 'gn_place_spheres':\nGroup Input\nGroup Output\nInstance on Points\nUV Sphere\n</pre> In\u00a0[10]: Copied! <pre>fresh_scene()\nimport mathutils\n\n# Create a new mesh and object for the point cloud\nmesh = bpy.data.meshes.new(\"HelloMesh\")\nmy_point_obj = bpy.data.objects.new(\"HelloPoint\", mesh)\npoints = [mathutils.Vector((6, 4, 0))]  # One point at coordinates\n# Apply the points to the mesh\nmesh.from_pydata(vertices = points, edges=[], faces=[])\nmesh.update()\nbpy.context.collection.objects.link(my_point_obj)\n\n\nbpy.context.scene.render.resolution_x = 300\nbpy.context.scene.render.resolution_y = 200\nrender_result()\n</pre> fresh_scene() import mathutils  # Create a new mesh and object for the point cloud mesh = bpy.data.meshes.new(\"HelloMesh\") my_point_obj = bpy.data.objects.new(\"HelloPoint\", mesh) points = [mathutils.Vector((6, 4, 0))]  # One point at coordinates # Apply the points to the mesh mesh.from_pydata(vertices = points, edges=[], faces=[]) mesh.update() bpy.context.collection.objects.link(my_point_obj)   bpy.context.scene.render.resolution_x = 300 bpy.context.scene.render.resolution_y = 200 render_result() In\u00a0[11]: Copied! <pre>modifier = my_point_obj.modifiers.new(name=\"GeometryNodes\", type='NODES')\nmodifier.node_group = node_group_place_spheres\nrender_result()\n</pre> modifier = my_point_obj.modifiers.new(name=\"GeometryNodes\", type='NODES') modifier.node_group = node_group_place_spheres render_result() In\u00a0[12]: Copied! <pre>my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 4 # set radius\nrender_result()\n</pre> my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 4 # set radius render_result() In\u00a0[13]: Copied! <pre>fresh_scene()\n\n# Create a new mesh and object for the point cloud\nmesh = bpy.data.meshes.new(\"HelloDenoMesh\")\nmy_point_obj = bpy.data.objects.new(\"HelloDeno\", mesh)\n\npoints = [mathutils.Vector((x, y, 0)) for x, y in zip(x_values, y_values)]  # Create points from DataFrame\n\n# Apply the points to the mesh\nmesh.from_pydata(vertices=points, edges=[], faces=[])\nmesh.update()\nbpy.context.collection.objects.link(my_point_obj)\n\n\nmodifier = my_point_obj.modifiers.new(name=\"GeometryNodes\", type='NODES')\nmodifier.node_group = node_group_place_spheres\n\nmy_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 0.2  # Set radius\n\ncamera_from_above()\nrender_result()\n</pre> fresh_scene()  # Create a new mesh and object for the point cloud mesh = bpy.data.meshes.new(\"HelloDenoMesh\") my_point_obj = bpy.data.objects.new(\"HelloDeno\", mesh)  points = [mathutils.Vector((x, y, 0)) for x, y in zip(x_values, y_values)]  # Create points from DataFrame  # Apply the points to the mesh mesh.from_pydata(vertices=points, edges=[], faces=[]) mesh.update() bpy.context.collection.objects.link(my_point_obj)   modifier = my_point_obj.modifiers.new(name=\"GeometryNodes\", type='NODES') modifier.node_group = node_group_place_spheres  my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 0.2  # Set radius  camera_from_above() render_result() In\u00a0[14]: Copied! <pre>my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 0.1  # Set radius\n\nrender_result()\n</pre> my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 0.1  # Set radius  render_result() In\u00a0[15]: Copied! <pre># \ud83d\udca1 Now we can squeeze or change anything in geonodes!\nrender_result()\n</pre> # \ud83d\udca1 Now we can squeeze or change anything in geonodes! render_result() In\u00a0[16]: Copied! <pre># Also possible to change the data points\nimport pandas as pd\nurl = 'https://raw.githubusercontent.com/kolibril13/ipydrop/refs/heads/main/star.csv'\ndf = pd.read_csv(url)\ndf.head()\n</pre> # Also possible to change the data points import pandas as pd url = 'https://raw.githubusercontent.com/kolibril13/ipydrop/refs/heads/main/star.csv' df = pd.read_csv(url) df.head() Out[16]: x y 0 58.213608 91.881892 1 58.196054 92.214989 2 58.718231 90.310532 3 57.278373 89.907607 4 58.082020 92.008145 In\u00a0[17]: Copied! <pre>x_values = df['x'] / 10 \ny_values = df['y'] / 10 * 0.8\n\nplt.axis('equal');\nplt.scatter(x_values, y_values);\n</pre> x_values = df['x'] / 10  y_values = df['y'] / 10 * 0.8  plt.axis('equal'); plt.scatter(x_values, y_values); In\u00a0[18]: Copied! <pre># Only update the vertex positions without clearing the geometry\nfor i, (x, y) in enumerate(zip(x_values, y_values)):\n    my_point_obj.data.vertices[i].co = (x, y, 0)\n\n# Update the mesh and force Blender to recalculate\nmy_point_obj.data.update()\nbpy.context.view_layer.update()\n</pre> # Only update the vertex positions without clearing the geometry for i, (x, y) in enumerate(zip(x_values, y_values)):     my_point_obj.data.vertices[i].co = (x, y, 0)  # Update the mesh and force Blender to recalculate my_point_obj.data.update() bpy.context.view_layer.update() In\u00a0[19]: Copied! <pre>render_result()\n</pre> render_result() In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"n2data_simple/#simple-data","title":"Simple data\u00b6","text":""},{"location":"n2data_simple/#loading-pre-defined-geometry-nodes","title":"Loading Pre-Defined Geometry Nodes\u00b6","text":""},{"location":"n3data_attributes/","title":"Data attributes","text":"In\u00a0[1]: Copied! <pre>import bpy\nfrom IPython.display import display, Image\n\ndef fresh_scene():\n    # Deselect all objects\n    bpy.ops.object.select_all(action='DESELECT')\n    # Select all objects except cameras\n    for obj in bpy.context.scene.objects:\n        if  obj.type != 'CAMERA':\n            obj.select_set(True)\n        else:\n            obj.select_set(False)\n    bpy.ops.object.delete()\n    \n    # add light\n    bpy.ops.object.light_add(type='SUN')\n    sun = bpy.context.object\n\n    sun.location = (0, 0, 0)\n    from math import radians\n    sun.rotation_euler = (radians(204), radians(-133), radians(-67))\n    sun.data.energy = 5  \n\n\ndef render_result():\n    bpy.ops.render.render()\n    bpy.data.images['Render Result'].save_render(filepath=\"img.png\")\n    display(Image(filename=\"img.png\"))\n\nbpy.context.scene.render.resolution_x = 500\nbpy.context.scene.render.resolution_y = 200\n</pre> import bpy from IPython.display import display, Image  def fresh_scene():     # Deselect all objects     bpy.ops.object.select_all(action='DESELECT')     # Select all objects except cameras     for obj in bpy.context.scene.objects:         if  obj.type != 'CAMERA':             obj.select_set(True)         else:             obj.select_set(False)     bpy.ops.object.delete()          # add light     bpy.ops.object.light_add(type='SUN')     sun = bpy.context.object      sun.location = (0, 0, 0)     from math import radians     sun.rotation_euler = (radians(204), radians(-133), radians(-67))     sun.data.energy = 5     def render_result():     bpy.ops.render.render()     bpy.data.images['Render Result'].save_render(filepath=\"img.png\")     display(Image(filename=\"img.png\"))  bpy.context.scene.render.resolution_x = 500 bpy.context.scene.render.resolution_y = 200 In\u00a0[2]: Copied! <pre># temp\nbpy.ops.wm.save_as_mainfile(filepath=\"scene.blend\")\n</pre> # temp bpy.ops.wm.save_as_mainfile(filepath=\"scene.blend\") <pre>Info: Total files 0 | Changed 0 | Failed 0\nInfo: Saved \"scene.blend\"\n</pre> Out[2]: <pre>{'FINISHED'}</pre> In\u00a0[3]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_plane_add(size=3, location=(0, 0, 0))  \nplane = bpy.context.object\n\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_plane_add(size=3, location=(0, 0, 0))   plane = bpy.context.object  render_result() In\u00a0[4]: Copied! <pre>num_vertices = len(plane.data.vertices)\nnum_vertices\n</pre> num_vertices = len(plane.data.vertices) num_vertices Out[4]: <pre>4</pre> In\u00a0[5]: Copied! <pre>vertices = [(v.co.x, v.co.y, v.co.z) for v in plane.data.vertices]\nimport pandas as pd\ndf = pd.DataFrame(vertices, columns=['X', 'Y', 'Z'])\ndf\n</pre> vertices = [(v.co.x, v.co.y, v.co.z) for v in plane.data.vertices] import pandas as pd df = pd.DataFrame(vertices, columns=['X', 'Y', 'Z']) df Out[5]: X Y Z 0 -1.5 -1.5 0.0 1 1.5 -1.5 0.0 2 -1.5 1.5 0.0 3 1.5 1.5 0.0 In\u00a0[6]: Copied! <pre>attr_name = 'my_float'\n\n# 'POINT' domain means each vertex gets the value\nattr = plane.data.attributes.new(name=attr_name,type='FLOAT',domain='POINT')\n\nvalues = [2.0, 3.0, 4.2, 5.2]\nattr.data.foreach_set('value', values)\nplane.data.update()\n\nrender_result()\n</pre> attr_name = 'my_float'  # 'POINT' domain means each vertex gets the value attr = plane.data.attributes.new(name=attr_name,type='FLOAT',domain='POINT')  values = [2.0, 3.0, 4.2, 5.2] attr.data.foreach_set('value', values) plane.data.update()  render_result() In\u00a0[7]: Copied! <pre># we can confirm this by checking with a dataframe:\ndf = pd.DataFrame({\n    'X': [v.co.x for v in plane.data.vertices],\n    'Y': [v.co.y for v in plane.data.vertices],\n    'Z': [v.co.z for v in plane.data.vertices],\n    'my_float': [val.value for val in plane.data.attributes['my_float'].data]\n})\n\ndf\n</pre> # we can confirm this by checking with a dataframe: df = pd.DataFrame({     'X': [v.co.x for v in plane.data.vertices],     'Y': [v.co.y for v in plane.data.vertices],     'Z': [v.co.z for v in plane.data.vertices],     'my_float': [val.value for val in plane.data.attributes['my_float'].data] })  df Out[7]: X Y Z my_float 0 -1.5 -1.5 0.0 2.0 1 1.5 -1.5 0.0 3.0 2 -1.5 1.5 0.0 4.2 3 1.5 1.5 0.0 5.2 In\u00a0[8]: Copied! <pre>blend_file_path = \"cube_gn_attribute.blend\"\nnode_group_name = \"gn_place_by_attribute\"\n\n# Load only the node group from the blend file\nwith bpy.data.libraries.load(blend_file_path, link=False) as (data_from, data_to):\n    if node_group_name in data_from.node_groups:\n        data_to.node_groups = [node_group_name]\n\n# Access the node group\nnode_group_place_spheres_attributes = bpy.data.node_groups[node_group_name]\n\n# Print all the node names inside the node group\nprint(f\"Nodes in node group '{node_group_name}':\")\nfor node in node_group_place_spheres_attributes.nodes:\n    print(node.name)\n</pre> blend_file_path = \"cube_gn_attribute.blend\" node_group_name = \"gn_place_by_attribute\"  # Load only the node group from the blend file with bpy.data.libraries.load(blend_file_path, link=False) as (data_from, data_to):     if node_group_name in data_from.node_groups:         data_to.node_groups = [node_group_name]  # Access the node group node_group_place_spheres_attributes = bpy.data.node_groups[node_group_name]  # Print all the node names inside the node group print(f\"Nodes in node group '{node_group_name}':\") for node in node_group_place_spheres_attributes.nodes:     print(node.name) <pre>Nodes in node group 'gn_place_by_attribute':\nGroup Input\nGroup Output\nInstance on Points\nNamed Attribute\nUV Sphere\n</pre> In\u00a0[9]: Copied! <pre># add geometry nodes\nmodifier = plane.modifiers.new(name=\"GeometryNodes\", type='NODES')\nmodifier.node_group = node_group_place_spheres_attributes\nrender_result()\n</pre> # add geometry nodes modifier = plane.modifiers.new(name=\"GeometryNodes\", type='NODES') modifier.node_group = node_group_place_spheres_attributes render_result() In\u00a0[10]: Copied! <pre>values = [10.0, 10.0, 10.2, 3.2]\nattr.data.foreach_set('value', values)\n\nrender_result()\n</pre> values = [10.0, 10.0, 10.2, 3.2] attr.data.foreach_set('value', values)  render_result() In\u00a0[11]: Copied! <pre># remove geometry nodes modifier again\nmodifier = plane.modifiers.get(\"GeometryNodes\")\nplane.modifiers.remove(modifier)\nrender_result()\n</pre> # remove geometry nodes modifier again modifier = plane.modifiers.get(\"GeometryNodes\") plane.modifiers.remove(modifier) render_result() In\u00a0[12]: Copied! <pre># There are many more types of attributes that can be created!\n# I found a complete list here:\n# 'FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BYTE_COLOR', 'STRING', 'BOOLEAN', 'FLOAT2', 'INT8', 'INT32_2D', 'QUATERNION', 'FLOAT4X4\n# from this error message:\nplane.data.attributes.new(name=attr_name,type='brrrrr',domain='POINT')\n</pre> # There are many more types of attributes that can be created! # I found a complete list here: # 'FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BYTE_COLOR', 'STRING', 'BOOLEAN', 'FLOAT2', 'INT8', 'INT32_2D', 'QUATERNION', 'FLOAT4X4 # from this error message: plane.data.attributes.new(name=attr_name,type='brrrrr',domain='POINT') <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[12], line 5\n      1 # There are many more types of attributes that can be created!\n      2 # I found a complete list here:\n      3 # 'FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BYTE_COLOR', 'STRING', 'BOOLEAN', 'FLOAT2', 'INT8', 'INT32_2D', 'QUATERNION', 'FLOAT4X4\n      4 # from this error message:\n----&gt; 5 plane.data.attributes.new(name=attr_name,type='brrrrr',domain='POINT')\n\nTypeError: AttributeGroup.new(): error with keyword argument \"type\" -  enum \"brrrrr\" not found in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BYTE_COLOR', 'STRING', 'BOOLEAN', 'FLOAT2', 'INT8', 'INT32_2D', 'QUATERNION', 'FLOAT4X4')</pre> In\u00a0[13]: Copied! <pre>if 'my_int' in plane.data.attributes:\n    plane.data.attributes.remove(plane.data.attributes['my_int'])\n\n# 'POINT' domain means each vertex gets the value\nattr = plane.data.attributes.new(name=\"my_int\",type='INT',domain='POINT')\nvalues = [2, 3, 4, 2]\nattr.data.foreach_set('value', values)\nplane.data.update()\nrender_result()\n</pre> if 'my_int' in plane.data.attributes:     plane.data.attributes.remove(plane.data.attributes['my_int'])  # 'POINT' domain means each vertex gets the value attr = plane.data.attributes.new(name=\"my_int\",type='INT',domain='POINT') values = [2, 3, 4, 2] attr.data.foreach_set('value', values) plane.data.update() render_result() In\u00a0[14]: Copied! <pre>if 'my_color' in plane.data.attributes:\n    plane.data.attributes.remove(plane.data.attributes['my_color'])\n\nattr = plane.data.attributes.new(name='my_color', type='FLOAT_COLOR', domain='POINT')\nvalues = [\n    (1.0, 0.5, 0.0, 1.0), # \"Orange 1\n    (1.0, 0.4, 0.1, 1.0), # \"Orange 2\n    (1.0, 0.3, 0.2, 1.0), # \"Orange 3\n    (1.0, 0.2, 0.1, 1.0), # \"Orange 4\n]\nfor i, color in enumerate(values):\n    attr.data[i].color = color\n\nplane.data.update()\nrender_result()\n</pre> if 'my_color' in plane.data.attributes:     plane.data.attributes.remove(plane.data.attributes['my_color'])  attr = plane.data.attributes.new(name='my_color', type='FLOAT_COLOR', domain='POINT') values = [     (1.0, 0.5, 0.0, 1.0), # \"Orange 1     (1.0, 0.4, 0.1, 1.0), # \"Orange 2     (1.0, 0.3, 0.2, 1.0), # \"Orange 3     (1.0, 0.2, 0.1, 1.0), # \"Orange 4 ] for i, color in enumerate(values):     attr.data[i].color = color  plane.data.update() render_result() In\u00a0[15]: Copied! <pre># add shader nodes\nmaterial = bpy.data.materials.new(name=\"MyMaterial\")\nmaterial.use_nodes = True\n\nnodes = material.node_tree.nodes\nlinks = material.node_tree.links\n\nfor node in nodes:\n    nodes.remove(node)\n\nattribute_node = nodes.new(type=\"ShaderNodeAttribute\")\nattribute_node.location = (-600, 0)\nattribute_node.attribute_name = \"my_color\"\n\nprincipled_node = nodes.new(type=\"ShaderNodeBsdfPrincipled\")\nprincipled_node.location = (-200, 0)\n\noutput_node = nodes.new(type=\"ShaderNodeOutputMaterial\")\noutput_node.location = (200, 0)\n\nlinks.new(attribute_node.outputs['Color'], principled_node.inputs['Base Color'])\nlinks.new(principled_node.outputs['BSDF'], output_node.inputs['Surface'])\n\n# Ensure the object has at least one material slot\nif len(plane.data.materials) == 0:\n    plane.data.materials.append(material)\nelse:\n    plane.data.materials[0] = material\n\nrender_result()\n</pre> # add shader nodes material = bpy.data.materials.new(name=\"MyMaterial\") material.use_nodes = True  nodes = material.node_tree.nodes links = material.node_tree.links  for node in nodes:     nodes.remove(node)  attribute_node = nodes.new(type=\"ShaderNodeAttribute\") attribute_node.location = (-600, 0) attribute_node.attribute_name = \"my_color\"  principled_node = nodes.new(type=\"ShaderNodeBsdfPrincipled\") principled_node.location = (-200, 0)  output_node = nodes.new(type=\"ShaderNodeOutputMaterial\") output_node.location = (200, 0)  links.new(attribute_node.outputs['Color'], principled_node.inputs['Base Color']) links.new(principled_node.outputs['BSDF'], output_node.inputs['Surface'])  # Ensure the object has at least one material slot if len(plane.data.materials) == 0:     plane.data.materials.append(material) else:     plane.data.materials[0] = material  render_result() In\u00a0[16]: Copied! <pre># Add vector attribute\n\nif 'my_vector' in plane.data.attributes:\n    plane.data.attributes.remove(plane.data.attributes['my_vector'])\n\nattr = plane.data.attributes.new(name='my_vector', type='FLOAT_VECTOR', domain='POINT')\nvalues = [\n    (0.4, 0.4, -1.0),\n    (0.2, 0.3, 0.9),\n    (0.5, 0.5, 0.5),\n    (0.6, 0.9, 1.3)\n]\nfor i, vector in enumerate(values):\n    attr.data[i].vector = vector\n\nplane.data.update()\n</pre> # Add vector attribute  if 'my_vector' in plane.data.attributes:     plane.data.attributes.remove(plane.data.attributes['my_vector'])  attr = plane.data.attributes.new(name='my_vector', type='FLOAT_VECTOR', domain='POINT') values = [     (0.4, 0.4, -1.0),     (0.2, 0.3, 0.9),     (0.5, 0.5, 0.5),     (0.6, 0.9, 1.3) ] for i, vector in enumerate(values):     attr.data[i].vector = vector  plane.data.update() In\u00a0[17]: Copied! <pre>geo_nodes = plane.modifiers.new(name=\"GeometryNodes\", type=\"NODES\")\n\nnode_group = bpy.data.node_groups.new(name=\"GeometryNodes\", type=\"GeometryNodeTree\")\ngeo_nodes.node_group = node_group\n\ngroup_input = node_group.nodes.new(type=\"NodeGroupInput\")\ngroup_input.location = (0, 0)\n\ngroup_output = node_group.nodes.new(type=\"NodeGroupOutput\")\ngroup_output.location = (600, 0)\n\nnode_group.interface.new_socket(name=\"Geometry\", in_out=\"INPUT\", socket_type=\"NodeSocketGeometry\")\nnode_group.interface.new_socket(name=\"Geometry\", in_out=\"OUTPUT\", socket_type=\"NodeSocketGeometry\")\n\nset_position = node_group.nodes.new(type=\"GeometryNodeSetPosition\")\nset_position.location = (300, 0)\n\nnamed_attribute = node_group.nodes.new(type=\"GeometryNodeInputNamedAttribute\")\nnamed_attribute.location = (100, -200)\nnamed_attribute.data_type = 'FLOAT_VECTOR'\nnamed_attribute.inputs[\"Name\"].default_value = \"my_vector\"\n\nnode_group.links.new(group_input.outputs[\"Geometry\"], set_position.inputs[\"Geometry\"])\nnode_group.links.new(set_position.outputs[\"Geometry\"], group_output.inputs[\"Geometry\"])\n\nnode_group.links.new(named_attribute.outputs[\"Attribute\"], set_position.inputs[\"Offset\"])\n\nrender_result()\n</pre>  geo_nodes = plane.modifiers.new(name=\"GeometryNodes\", type=\"NODES\")  node_group = bpy.data.node_groups.new(name=\"GeometryNodes\", type=\"GeometryNodeTree\") geo_nodes.node_group = node_group  group_input = node_group.nodes.new(type=\"NodeGroupInput\") group_input.location = (0, 0)  group_output = node_group.nodes.new(type=\"NodeGroupOutput\") group_output.location = (600, 0)  node_group.interface.new_socket(name=\"Geometry\", in_out=\"INPUT\", socket_type=\"NodeSocketGeometry\") node_group.interface.new_socket(name=\"Geometry\", in_out=\"OUTPUT\", socket_type=\"NodeSocketGeometry\")  set_position = node_group.nodes.new(type=\"GeometryNodeSetPosition\") set_position.location = (300, 0)  named_attribute = node_group.nodes.new(type=\"GeometryNodeInputNamedAttribute\") named_attribute.location = (100, -200) named_attribute.data_type = 'FLOAT_VECTOR' named_attribute.inputs[\"Name\"].default_value = \"my_vector\"  node_group.links.new(group_input.outputs[\"Geometry\"], set_position.inputs[\"Geometry\"]) node_group.links.new(set_position.outputs[\"Geometry\"], group_output.inputs[\"Geometry\"])  node_group.links.new(named_attribute.outputs[\"Attribute\"], set_position.inputs[\"Offset\"])  render_result() In\u00a0[18]: Copied! <pre>import pandas as pd\nimport bpy\n\n# Assume you are working with the plane object\nplane = bpy.data.objects['Plane']\n\n# Create the DataFrame for coordinates\ndf = pd.DataFrame({\n    'X': [v.co.x for v in plane.data.vertices],\n    'Y': [v.co.y for v in plane.data.vertices],\n    'Z': [v.co.z for v in plane.data.vertices]\n})\n\n# Add custom attributes if they exist\n\n# Add my_float attribute\nif 'my_float' in plane.data.attributes:\n    df['my_float'] = [attr.value for attr in plane.data.attributes['my_float'].data]\n\n# Add my_int attribute\nif 'my_int' in plane.data.attributes:\n    df['my_int'] = [attr.value for attr in plane.data.attributes['my_int'].data]\n\n# Add my_color attribute and round to 2 decimal places\nif 'my_color' in plane.data.attributes:\n    df['my_color'] = [tuple(round(c, 3) for c in attr.color) for attr in plane.data.attributes['my_color'].data]\n\n# Add my_vector attribute\nif 'my_vector' in plane.data.attributes:\n    df['my_vector'] = [tuple(round(c, 3) for c in attr.vector) for attr in plane.data.attributes['my_vector'].data]\n\n# Display the DataFrame\ndf\n</pre> import pandas as pd import bpy  # Assume you are working with the plane object plane = bpy.data.objects['Plane']  # Create the DataFrame for coordinates df = pd.DataFrame({     'X': [v.co.x for v in plane.data.vertices],     'Y': [v.co.y for v in plane.data.vertices],     'Z': [v.co.z for v in plane.data.vertices] })  # Add custom attributes if they exist  # Add my_float attribute if 'my_float' in plane.data.attributes:     df['my_float'] = [attr.value for attr in plane.data.attributes['my_float'].data]  # Add my_int attribute if 'my_int' in plane.data.attributes:     df['my_int'] = [attr.value for attr in plane.data.attributes['my_int'].data]  # Add my_color attribute and round to 2 decimal places if 'my_color' in plane.data.attributes:     df['my_color'] = [tuple(round(c, 3) for c in attr.color) for attr in plane.data.attributes['my_color'].data]  # Add my_vector attribute if 'my_vector' in plane.data.attributes:     df['my_vector'] = [tuple(round(c, 3) for c in attr.vector) for attr in plane.data.attributes['my_vector'].data]  # Display the DataFrame df Out[18]: X Y Z my_float my_int my_color my_vector 0 -1.5 -1.5 0.0 10.0 2 (1.0, 0.5, 0.0, 1.0) (0.4, 0.4, -1.0) 1 1.5 -1.5 0.0 10.0 3 (1.0, 0.4, 0.1, 1.0) (0.2, 0.3, 0.9) 2 -1.5 1.5 0.0 10.2 4 (1.0, 0.3, 0.2, 1.0) (0.5, 0.5, 0.5) 3 1.5 1.5 0.0 3.2 2 (1.0, 0.2, 0.1, 1.0) (0.6, 0.9, 1.3) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"n3data_attributes/#data-attributes","title":"Data attributes\u00b6","text":""},{"location":"n3data_attributes/#adding-a-float","title":"Adding a Float\u00b6","text":""},{"location":"n3data_attributes/#now-lets-use-the-attribute-in-geometry-nodes","title":"Now let's use the attribute in Geometry Nodes!\u00b6","text":""},{"location":"n3data_attributes/#add-int","title":"Add INT\u00b6","text":""},{"location":"n3data_attributes/#add-color","title":"ADD COLOR\u00b6","text":""}]}