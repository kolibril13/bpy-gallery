{"config":{"lang":["en"],"separator":"[\\s\\-_,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bpy Gallery","text":"<p>Welcome to this documentation! \ud83d\udc4b Here, you\u2019ll find a collection of curated examples for using Blender within Python notebooks. If you find these resources helpful, feel free to leave a star \u2b50 on GitHub: https://github.com/kolibril13/bpy-gallery</p>"},{"location":"demo/","title":"Demo - Jupyter Blender","text":"In\u00a0[43]: Copied! <pre>import bpy\ncube = bpy.data.objects['Cube']\n</pre> import bpy cube = bpy.data.objects['Cube'] In\u00a0[44]: Copied! <pre>import anywidget\nimport traitlets\n\nclass CounterWidget(anywidget.AnyWidget):\n    _esm = \"\"\"\n    function render({ model, el }) {\n      let button = document.createElement(\"button\");\n      button.innerHTML = `count is ${model.get(\"value\")}`;\n      button.addEventListener(\"click\", () =&gt; {\n        model.set(\"value\", model.get(\"value\") + 1);\n        model.save_changes();\n      });\n      model.on(\"change:value\", () =&gt; {\n        button.innerHTML = `count is ${model.get(\"value\")}`;\n      });\n      el.classList.add(\"counter-widget\");\n      el.appendChild(button);\n    }\n    export default { render };\n    \"\"\"\n    _css = \"\"\"\n    .counter-widget button { color: red; font-size: 1.75rem; background-color: #ffeb3b; padding: 0.5rem 1rem; border: none; border-radius: 0.25rem; }\n    .counter-widget button:hover { background-color: #fbc02d; }\n    \"\"\"\n    value = traitlets.Int(0).tag(sync=True)\n\ndef update_cube_position(counter_value):\n    # Calculate z position based on counter value\n    z_shift = counter_value * 0.5\n    \n    # Update the cube's z position\n    cube.location.z = z_shift\n    \n    # Update the view\n    bpy.context.view_layer.update()\n\n# Function to handle counter value changes\ndef on_counter_change(change):\n    update_cube_position(change['new'])\n    bpy.context.view_layer.update()\n\nwidget = CounterWidget(value=-2)\n# Observe the counter\nwidget.observe(on_counter_change, names='value')\n\n# Initial update of the cube's position\nupdate_cube_position(widget.value)\n\nwidget \n</pre> import anywidget import traitlets  class CounterWidget(anywidget.AnyWidget):     _esm = \"\"\"     function render({ model, el }) {       let button = document.createElement(\"button\");       button.innerHTML = `count is ${model.get(\"value\")}`;       button.addEventListener(\"click\", () =&gt; {         model.set(\"value\", model.get(\"value\") + 1);         model.save_changes();       });       model.on(\"change:value\", () =&gt; {         button.innerHTML = `count is ${model.get(\"value\")}`;       });       el.classList.add(\"counter-widget\");       el.appendChild(button);     }     export default { render };     \"\"\"     _css = \"\"\"     .counter-widget button { color: red; font-size: 1.75rem; background-color: #ffeb3b; padding: 0.5rem 1rem; border: none; border-radius: 0.25rem; }     .counter-widget button:hover { background-color: #fbc02d; }     \"\"\"     value = traitlets.Int(0).tag(sync=True)  def update_cube_position(counter_value):     # Calculate z position based on counter value     z_shift = counter_value * 0.5          # Update the cube's z position     cube.location.z = z_shift          # Update the view     bpy.context.view_layer.update()  # Function to handle counter value changes def on_counter_change(change):     update_cube_position(change['new'])     bpy.context.view_layer.update()  widget = CounterWidget(value=-2) # Observe the counter widget.observe(on_counter_change, names='value')  # Initial update of the cube's position update_cube_position(widget.value)  widget  Out[44]: <pre>CounterWidget(value=-2)</pre> In\u00a0[\u00a0]: Copied! <pre>s\n</pre> s"},{"location":"demo/#demo-jupyter-blender","title":"Demo - Jupyter Blender\u00b6","text":""},{"location":"n0getting_started/","title":"Getting Started","text":""},{"location":"n0getting_started/#how-can-i-use-blender-with-python","title":"How can I use Blender with Python?","text":"<p>Blender has a built-in Python editor, but sometimes it\u2019s useful to work in environments like Jupyter notebooks or VS Code notebooks.</p> <p>There are two ways to use Blender in a notebook:  </p> <ol> <li>Headless Mode: In this mode, you install the Blender Python module bpy from PyPi. The Blender GUI doesn\u2019t open, so you can run it even without a Blender installation.  </li> <li>GUI Mode: This mode uses your installed Blender version, so you can work in the Blender GUI while sending commands from the notebook.</li> </ol>"},{"location":"n0getting_started/#work-in-progress","title":"WORK IN PROGRESS.","text":"<p>Probably in March 2025 there will be a new guide on how to use Blender w. Jupyter. Till then, here's the repo for further installation instructions: https://github.com/Octoframes/bpy_jupyter</p>"},{"location":"n1objects/","title":"Adding Objects","text":"In\u00a0[36]: Copied! <pre>import bpy\nbpy.app.version_string # current blender version\n</pre> import bpy bpy.app.version_string # current blender version Out[36]: <pre>'4.5.0'</pre> In\u00a0[37]: Copied! <pre>import runpy # Helper functions just for the docs\nmodule = runpy.run_path(\"/Users/jan-hendrik/projects/bpy-gallery/docs/render_utils.py\")\nglobals().update(module)\n\n# Set render resolution\nbpy.context.scene.render.resolution_x = 500\nbpy.context.scene.render.resolution_y = 200\n</pre> import runpy # Helper functions just for the docs module = runpy.run_path(\"/Users/jan-hendrik/projects/bpy-gallery/docs/render_utils.py\") globals().update(module)  # Set render resolution bpy.context.scene.render.resolution_x = 500 bpy.context.scene.render.resolution_y = 200 In\u00a0[38]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_monkey_add(size=2.5, location=(0, 0, 0))\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_monkey_add(size=2.5, location=(0, 0, 0)) render_result() In\u00a0[39]: Copied! <pre>fresh_scene()\n#bpy.ops.object.gpencil_add(location=(0, 0, 0), type='STROKE') # Blender 4.2\nbpy.ops.object.grease_pencil_add(location=(0, 0, 0), type=\"STROKE\") # Blender 4.3.1\ngpencil_object = bpy.context.active_object\ngpencil_object.scale = (3, 3, 3)\nrender_result()\n</pre> fresh_scene() #bpy.ops.object.gpencil_add(location=(0, 0, 0), type='STROKE') # Blender 4.2 bpy.ops.object.grease_pencil_add(location=(0, 0, 0), type=\"STROKE\") # Blender 4.3.1 gpencil_object = bpy.context.active_object gpencil_object.scale = (3, 3, 3) render_result() In\u00a0[40]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_uv_sphere_add(radius=1.5, location=(0, 0, 0))  render_result() In\u00a0[41]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cone_add(radius1=1, depth=2, location=(0, 0, 0))  \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cone_add(radius1=1, depth=2, location=(0, 0, 0))   render_result() In\u00a0[42]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(0, 0, 0))  render_result() In\u00a0[43]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_torus_add(major_radius=2, minor_radius=0.3, location=(0,0, 0))\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_torus_add(major_radius=2, minor_radius=0.3, location=(0,0, 0)) render_result() In\u00a0[44]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_ico_sphere_add(radius=1, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_ico_sphere_add(radius=1, location=(0, 0, 0))  render_result() In\u00a0[45]: Copied! <pre>fresh_scene()\nbpy.ops.object.text_add(location=(-4, 0, 0))\ntext = bpy.context.active_object\ntext.data.body = \"Hello \ud83d\ude04\"\ntext.scale = (2, 2, 2)\nrender_result()\n</pre> fresh_scene() bpy.ops.object.text_add(location=(-4, 0, 0)) text = bpy.context.active_object text.data.body = \"Hello \ud83d\ude04\" text.scale = (2, 2, 2) render_result() In\u00a0[46]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_plane_add(size=3, location=(0, 0, 0))  \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_plane_add(size=3, location=(0, 0, 0))   render_result() In\u00a0[47]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_circle_add(radius=2.5, location=(0, 0, 0), fill_type='NGON')\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_circle_add(radius=2.5, location=(0, 0, 0), fill_type='NGON') render_result() In\u00a0[48]: Copied! <pre>fresh_scene()\nbpy.ops.object.empty_add(type='PLAIN_AXES', location=(4, 0, 0)) # (This is not shown in the image, but it is there)\nrender_result()\n</pre> fresh_scene() bpy.ops.object.empty_add(type='PLAIN_AXES', location=(4, 0, 0)) # (This is not shown in the image, but it is there) render_result() In\u00a0[49]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) \nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))  render_result() In\u00a0[50]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) \nlight = bpy.data.objects.new(\"Light\", bpy.data.lights.new(\"Light\", 'POINT'))\nlight.location = (3, 0, 2)\nlight.data.energy = 8000\nbpy.context.collection.objects.link(light)\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))  light = bpy.data.objects.new(\"Light\", bpy.data.lights.new(\"Light\", 'POINT')) light.location = (3, 0, 2) light.data.energy = 8000 bpy.context.collection.objects.link(light) render_result() In\u00a0[51]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) \ncube = bpy.context.active_object\nbevel_modifier = cube.modifiers.new(name=\"Bevel\", type='BEVEL')\nbevel_modifier.width = 0.4  # Adjust the bevel width\nbevel_modifier.segments = 5  # Number of segments for a smoother bevel\n\n# Optionally apply the modifier if needed (not necessary for visualization)\n# bpy.ops.object.modifier_apply(modifier=\"Bevel\")\n\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))  cube = bpy.context.active_object bevel_modifier = cube.modifiers.new(name=\"Bevel\", type='BEVEL') bevel_modifier.width = 0.4  # Adjust the bevel width bevel_modifier.segments = 5  # Number of segments for a smoother bevel  # Optionally apply the modifier if needed (not necessary for visualization) # bpy.ops.object.modifier_apply(modifier=\"Bevel\")  render_result() In\u00a0[52]: Copied! <pre>fresh_scene()\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create the subdivision surface modifier and change it to 'SIMPLE'\nsubsurf_modifier = cube.modifiers.new(name=\"Subdivision\", type='SUBSURF')\nsubsurf_modifier.subdivision_type = 'SIMPLE'  # Change to 'SIMPLE' instead of 'CATMULL_CLARK'\nsubsurf_modifier.levels = 4  # Viewport subdivision level\nsubsurf_modifier.render_levels = 4  # Render subdivision level\n\ndisplace_modifier = cube.modifiers.new(name=\"Displace\", type='DISPLACE')\ndisplace_modifier.strength = 0.5  # Adjust the displacement strength\n\ntexture = bpy.data.textures.new(\"DisplaceTexture\", type='CLOUDS')\ntexture.noise_scale = 1  # Reduce the noise scale to make it more detailed\ndisplace_modifier.texture = texture  # Assign the texture to the modifier\n\nrender_result()\n</pre> fresh_scene() bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create the subdivision surface modifier and change it to 'SIMPLE' subsurf_modifier = cube.modifiers.new(name=\"Subdivision\", type='SUBSURF') subsurf_modifier.subdivision_type = 'SIMPLE'  # Change to 'SIMPLE' instead of 'CATMULL_CLARK' subsurf_modifier.levels = 4  # Viewport subdivision level subsurf_modifier.render_levels = 4  # Render subdivision level  displace_modifier = cube.modifiers.new(name=\"Displace\", type='DISPLACE') displace_modifier.strength = 0.5  # Adjust the displacement strength  texture = bpy.data.textures.new(\"DisplaceTexture\", type='CLOUDS') texture.noise_scale = 1  # Reduce the noise scale to make it more detailed displace_modifier.texture = texture  # Assign the texture to the modifier  render_result() In\u00a0[54]: Copied! <pre># current blender version\nbpy.app.version_string\n</pre> # current blender version bpy.app.version_string Out[54]: <pre>'4.5.0'</pre> In\u00a0[55]: Copied! <pre># current blender version\nbpy.context.scene.render.engine\n</pre> # current blender version bpy.context.scene.render.engine Out[55]: <pre>'BLENDER_EEVEE_NEXT'</pre> In\u00a0[56]: Copied! <pre>bpy.context.scene.render.resolution_x, bpy.context.scene.render.resolution_y\n</pre> bpy.context.scene.render.resolution_x, bpy.context.scene.render.resolution_y Out[56]: <pre>(500, 200)</pre> In\u00a0[57]: Copied! <pre>bpy.context.scene.name\n</pre> bpy.context.scene.name Out[57]: <pre>'Scene'</pre> In\u00a0[58]: Copied! <pre>bpy.context.active_object.name\n</pre> bpy.context.active_object.name Out[58]: <pre>'Cube'</pre> In\u00a0[59]: Copied! <pre>bpy.context.active_object.location\n</pre> bpy.context.active_object.location Out[59]: <pre>Vector((0.0, 0.0, 0.0))</pre> In\u00a0[60]: Copied! <pre>bpy.context.collection.objects.keys()\n</pre> bpy.context.collection.objects.keys() Out[60]: <pre>['Camera', 'Sun', 'Cube']</pre> In\u00a0[61]: Copied! <pre>bpy.context.collection.objects.values()\n</pre> bpy.context.collection.objects.values() Out[61]: <pre>[bpy.data.objects['Camera'], bpy.data.objects['Sun'], bpy.data.objects['Cube']]</pre> In\u00a0[62]: Copied! <pre>fresh_scene()\n\n# Add a cube\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create and assign a green material to the cube without using nodes\nmat = bpy.data.materials.new(name=\"GreenMaterial\")\nmat.diffuse_color = (0, 1, 0, 1)  # Green color (R, G, B, A)\n\n# Apply material to the cube\ncube.data.materials.clear()  # Clear any existing materials\ncube.data.materials.append(mat)\n\nrender_result()\n</pre> fresh_scene()  # Add a cube bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create and assign a green material to the cube without using nodes mat = bpy.data.materials.new(name=\"GreenMaterial\") mat.diffuse_color = (0, 1, 0, 1)  # Green color (R, G, B, A)  # Apply material to the cube cube.data.materials.clear()  # Clear any existing materials cube.data.materials.append(mat)  render_result() In\u00a0[63]: Copied! <pre>fresh_scene()\n\n# colors with nodes\n\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create and assign a blue material to the cube\nmat = bpy.data.materials.new(name=\"BlueMaterial\")\nmat.use_nodes = True\nbsdf = mat.node_tree.nodes.get('Principled BSDF')\nbsdf.inputs['Base Color'].default_value = (0, 0, 1, 1)  # Blue color (R, G, B, A)\n\n# Apply material to the cube\ncube.data.materials.clear()  # Clear any existing materials\ncube.data.materials.append(mat)\nrender_result()\n</pre> fresh_scene()  # colors with nodes  bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create and assign a blue material to the cube mat = bpy.data.materials.new(name=\"BlueMaterial\") mat.use_nodes = True bsdf = mat.node_tree.nodes.get('Principled BSDF') bsdf.inputs['Base Color'].default_value = (0, 0, 1, 1)  # Blue color (R, G, B, A)  # Apply material to the cube cube.data.materials.clear()  # Clear any existing materials cube.data.materials.append(mat) render_result() In\u00a0[64]: Copied! <pre>fresh_scene()\n\nbpy.ops.mesh.primitive_plane_add(size=6, location=(0, 0, 0))\n# plane = bpy.context.object # only blender 4.1\nplane = bpy.context.active_object #blender 4.3\n\nmaterial = bpy.data.materials.new(name=\"ImageMaterial\")\nmaterial.use_nodes = True\nbsdf = material.node_tree.nodes[\"Principled BSDF\"]\n\ntex_image = material.node_tree.nodes.new('ShaderNodeTexImage')\n\npath = Path.home() / \"projects/bpy-gallery/docs/cute_dog.jpg\" \n\ntex_image.image = bpy.data.images.load(str(path))\n\nmaterial.node_tree.links.new(bsdf.inputs['Base Color'], tex_image.outputs['Color'])\nplane.data.materials.append(material)\n\nrender_result()\n</pre> fresh_scene()  bpy.ops.mesh.primitive_plane_add(size=6, location=(0, 0, 0)) # plane = bpy.context.object # only blender 4.1 plane = bpy.context.active_object #blender 4.3  material = bpy.data.materials.new(name=\"ImageMaterial\") material.use_nodes = True bsdf = material.node_tree.nodes[\"Principled BSDF\"]  tex_image = material.node_tree.nodes.new('ShaderNodeTexImage')  path = Path.home() / \"projects/bpy-gallery/docs/cute_dog.jpg\"   tex_image.image = bpy.data.images.load(str(path))  material.node_tree.links.new(bsdf.inputs['Base Color'], tex_image.outputs['Color']) plane.data.materials.append(material)  render_result() In\u00a0[65]: Copied! <pre>fresh_scene()\n\n# Working with shader nodes is possible, but get's quite involved quite quickly\n\n# Add a cube\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Create a new material for the cube\nmaterial = bpy.data.materials.new(name=\"YellowToOrangeGradient\")\nmaterial.use_nodes = True\nnodes = material.node_tree.nodes\n\n# Clear default nodes\nfor node in nodes:\n    nodes.remove(node)\n\n# Add a Gradient Texture\ngradient = nodes.new(type=\"ShaderNodeTexGradient\")\ngradient.gradient_type = \"LINEAR\"\ngradient.location = (0, 0)\n\n# Add a Color Ramp to control the gradient colors\nramp = nodes.new(type=\"ShaderNodeValToRGB\")\nramp.color_ramp.interpolation = \"LINEAR\"\nramp.location = (300, 0)\n\nramp.color_ramp.elements[0].color = (1, 1, 0, 1)  # Yellow (R, G, B, A)\nramp.color_ramp.elements[1].color = (1, 0.3, 0, 1)  # Orange (R, G, B, A)\n\n# Add the Principled BSDF shader\nbsdf = nodes.new(type=\"ShaderNodeBsdfPrincipled\")\nbsdf.location = (600, 0)\n\n# Create the output node\noutput = nodes.new(type=\"ShaderNodeOutputMaterial\")\noutput.location = (900, 0)\n\n# Link the nodes together\nlinks = material.node_tree.links\nlinks.new(gradient.outputs[\"Color\"], ramp.inputs[0])\nlinks.new(ramp.outputs[\"Color\"], bsdf.inputs[\"Base Color\"])\nlinks.new(bsdf.outputs[\"BSDF\"], output.inputs[\"Surface\"])\n\n# Apply the material to the cube\ncube.data.materials.clear()  # Clear any existing materials\ncube.data.materials.append(material)\n\nrender_result()\n</pre> fresh_scene()  # Working with shader nodes is possible, but get's quite involved quite quickly  # Add a cube bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Create a new material for the cube material = bpy.data.materials.new(name=\"YellowToOrangeGradient\") material.use_nodes = True nodes = material.node_tree.nodes  # Clear default nodes for node in nodes:     nodes.remove(node)  # Add a Gradient Texture gradient = nodes.new(type=\"ShaderNodeTexGradient\") gradient.gradient_type = \"LINEAR\" gradient.location = (0, 0)  # Add a Color Ramp to control the gradient colors ramp = nodes.new(type=\"ShaderNodeValToRGB\") ramp.color_ramp.interpolation = \"LINEAR\" ramp.location = (300, 0)  ramp.color_ramp.elements[0].color = (1, 1, 0, 1)  # Yellow (R, G, B, A) ramp.color_ramp.elements[1].color = (1, 0.3, 0, 1)  # Orange (R, G, B, A)  # Add the Principled BSDF shader bsdf = nodes.new(type=\"ShaderNodeBsdfPrincipled\") bsdf.location = (600, 0)  # Create the output node output = nodes.new(type=\"ShaderNodeOutputMaterial\") output.location = (900, 0)  # Link the nodes together links = material.node_tree.links links.new(gradient.outputs[\"Color\"], ramp.inputs[0]) links.new(ramp.outputs[\"Color\"], bsdf.inputs[\"Base Color\"]) links.new(bsdf.outputs[\"BSDF\"], output.inputs[\"Surface\"])  # Apply the material to the cube cube.data.materials.clear()  # Clear any existing materials cube.data.materials.append(material)  render_result() In\u00a0[66]: Copied! <pre>fresh_scene()\n\n# Setting up geonodes is possible, but get's quite involved quite quickly\n\n# Add a cube\nbpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0))\ncube = bpy.context.active_object\n\n# Setup geometry nodes\ngeo_nodes = cube.modifiers.new(name=\"GeometryNodes\", type=\"NODES\")\nnode_group = bpy.data.node_groups.new(\"GeometryNodes\", \"GeometryNodeTree\")\ngeo_nodes.node_group = node_group\n\n# Create input/output and transformation nodes\ninNode = node_group.nodes.new(\"NodeGroupInput\")\ninNode.location = (0, 0)\n\ntransformNode = node_group.nodes.new(\"GeometryNodeTransform\")\ntransformNode.location = (300, 0)\ntransformNode.inputs[\"Scale\"].default_value = (3, 2, 1)\n\noutNode = node_group.nodes.new(\"NodeGroupOutput\")\noutNode.location = (600, 0)\n\n# Define geometry input/output sockets\nnode_group.interface.new_socket(name=\"Geometry\", in_out=\"INPUT\", socket_type=\"NodeSocketGeometry\")\nnode_group.interface.new_socket(name=\"Geometry\", in_out=\"OUTPUT\", socket_type=\"NodeSocketGeometry\")\n\n# Link the nodes together\nnode_group.links.new(inNode.outputs[\"Geometry\"], transformNode.inputs[\"Geometry\"])\nnode_group.links.new(transformNode.outputs[\"Geometry\"], outNode.inputs[\"Geometry\"])\n\nrender_result()\n</pre> fresh_scene()  # Setting up geonodes is possible, but get's quite involved quite quickly  # Add a cube bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 0)) cube = bpy.context.active_object  # Setup geometry nodes geo_nodes = cube.modifiers.new(name=\"GeometryNodes\", type=\"NODES\") node_group = bpy.data.node_groups.new(\"GeometryNodes\", \"GeometryNodeTree\") geo_nodes.node_group = node_group  # Create input/output and transformation nodes inNode = node_group.nodes.new(\"NodeGroupInput\") inNode.location = (0, 0)  transformNode = node_group.nodes.new(\"GeometryNodeTransform\") transformNode.location = (300, 0) transformNode.inputs[\"Scale\"].default_value = (3, 2, 1)  outNode = node_group.nodes.new(\"NodeGroupOutput\") outNode.location = (600, 0)  # Define geometry input/output sockets node_group.interface.new_socket(name=\"Geometry\", in_out=\"INPUT\", socket_type=\"NodeSocketGeometry\") node_group.interface.new_socket(name=\"Geometry\", in_out=\"OUTPUT\", socket_type=\"NodeSocketGeometry\")  # Link the nodes together node_group.links.new(inNode.outputs[\"Geometry\"], transformNode.inputs[\"Geometry\"]) node_group.links.new(transformNode.outputs[\"Geometry\"], outNode.inputs[\"Geometry\"])  render_result() In\u00a0[67]: Copied! <pre>path = str(Path.home() / 'Downloads/temp_scene.blend')\nbpy.ops.wm.save_as_mainfile(filepath=path) \n</pre> path = str(Path.home() / 'Downloads/temp_scene.blend') bpy.ops.wm.save_as_mainfile(filepath=path)  <pre>Info: Saved as \"temp_scene.blend\"\n</pre> Out[67]: <pre>{'FINISHED'}</pre> In\u00a0[68]: Copied! <pre>fresh_scene()\n#bpy.ops.wm.open_mainfile(filepath=\"donut.blend\") # this will loose kernel connection\n\npath = Path.home() / \"projects/bpy-gallery/docs/donut.blend\" \nfilepath= str(path)\n\n# Import all objects from the .blend file\nwith bpy.data.libraries.load(filepath, link=False) as (data_from, data_to):\n    data_to.objects = data_from.objects\n\n# Link imported objects to the current scene\nfor obj in data_to.objects:\n    if obj is not None:\n        bpy.context.collection.objects.link(obj)\n</pre> fresh_scene() #bpy.ops.wm.open_mainfile(filepath=\"donut.blend\") # this will loose kernel connection  path = Path.home() / \"projects/bpy-gallery/docs/donut.blend\"  filepath= str(path)  # Import all objects from the .blend file with bpy.data.libraries.load(filepath, link=False) as (data_from, data_to):     data_to.objects = data_from.objects  # Link imported objects to the current scene for obj in data_to.objects:     if obj is not None:         bpy.context.collection.objects.link(obj) In\u00a0[69]: Copied! <pre>import bpy\n\n# Name of the imported camera\ncamera_name = \"Camera.001\"\n\n# Get the imported camera object\ncamera_object = bpy.data.objects.get(camera_name)\n\nif camera_object:\n    # Set the camera as the active camera in the scene\n    bpy.context.scene.camera = camera_object\n    print(f\"{camera_name} is now the main camera.\")\nelse:\n    print(f\"Camera '{camera_name}' not found.\")\n</pre> import bpy  # Name of the imported camera camera_name = \"Camera.001\"  # Get the imported camera object camera_object = bpy.data.objects.get(camera_name)  if camera_object:     # Set the camera as the active camera in the scene     bpy.context.scene.camera = camera_object     print(f\"{camera_name} is now the main camera.\") else:     print(f\"Camera '{camera_name}' not found.\")  <pre>Camera.001 is now the main camera.\n</pre> In\u00a0[70]: Copied! <pre>bpy.context.scene.render.engine = \"BLENDER_WORKBENCH\" \n\nbpy.context.scene.render.resolution_x = 500\nbpy.context.scene.render.resolution_y = 200\n\nrender_result()\n</pre> bpy.context.scene.render.engine = \"BLENDER_WORKBENCH\"   bpy.context.scene.render.resolution_x = 500 bpy.context.scene.render.resolution_y = 200  render_result() In\u00a0[71]: Copied! <pre>bpy.context.scene.render.engine = \"BLENDER_EEVEE_NEXT\"\nrender_result()\n</pre> bpy.context.scene.render.engine = \"BLENDER_EEVEE_NEXT\" render_result() In\u00a0[72]: Copied! <pre>bpy.context.scene.render.engine = \"CYCLES\"\nbpy.context.scene.cycles.samples = 10\nrender_result()\n</pre> bpy.context.scene.render.engine = \"CYCLES\" bpy.context.scene.cycles.samples = 10 render_result() In\u00a0[73]: Copied! <pre>bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 0.1\nrender_result()\n</pre> bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 0.1 render_result() In\u00a0[74]: Copied! <pre>bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 2\nrender_result()\n</pre> bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 2 render_result() In\u00a0[75]: Copied! <pre>bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 10\nrender_result()\n</pre> bpy.data.objects['ICINGLong'].modifiers[\"GeometryNodes\"][\"Socket_3\"] = 10 render_result()"},{"location":"n1objects/#adding-objects","title":"Adding Objects\u00b6","text":""},{"location":"n1objects/#applying-modifiers","title":"Applying Modifiers\u00b6","text":""},{"location":"n1objects/#settings","title":"Settings\u00b6","text":""},{"location":"n1objects/#using-colors","title":"Using colors\u00b6","text":""},{"location":"n1objects/#setting-up-shaders","title":"Setting Up Shaders\u00b6","text":"<p>Here's an example to generate the following shader tree  It's quite a lot of code, so I would recommend to better set up nodes in the GUI.</p>"},{"location":"n1objects/#setting-up-geometry-nodes","title":"Setting up Geometry Nodes\u00b6","text":""},{"location":"n1objects/#save-file","title":"Save File\u00b6","text":"<p>You can any time also save your Blender file like this:</p>"},{"location":"n1objects/#load-file","title":"Load file\u00b6","text":""},{"location":"n1objects/#choose-render-engine","title":"Choose render engine\u00b6","text":""},{"location":"n1objects/#manipulate-geometry-nodes","title":"Manipulate geometry nodes\u00b6","text":""},{"location":"n2install_uninstall/","title":"Use of Python Packages","text":"In\u00a0[127]: Copied! <pre>import subprocess\nimport sys\nsubprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"polars\"])\nsubprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"databpy\"])\n</pre> import subprocess import sys subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"polars\"]) subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"databpy\"])  <pre>Collecting polars\n  Using cached polars-1.29.0-cp39-abi3-macosx_11_0_arm64.whl.metadata (14 kB)\nUsing cached polars-1.29.0-cp39-abi3-macosx_11_0_arm64.whl (31.1 MB)\nInstalling collected packages: polars\nSuccessfully installed polars-1.29.0\n</pre> <pre>\n[notice] A new release of pip is available: 24.0 -&gt; 25.1.1\n[notice] To update, run: /Applications/Blender.app/Contents/Resources/4.4/python/bin/python3.11 -m pip install --upgrade pip\n</pre> <pre>Requirement already satisfied: databpy in /Applications/Blender.app/Contents/Resources/4.4/python/lib/python3.11/site-packages (0.0.18)\nRequirement already satisfied: numpy&lt;2.0,&gt;=1.24.0 in /Applications/Blender.app/Contents/Resources/4.4/python/lib/python3.11/site-packages (from databpy) (1.26.4)\n</pre> <pre>\n[notice] A new release of pip is available: 24.0 -&gt; 25.1.1\n[notice] To update, run: /Applications/Blender.app/Contents/Resources/4.4/python/bin/python3.11 -m pip install --upgrade pip\n</pre> Out[127]: <pre>0</pre> In\u00a0[129]: Copied! <pre>import subprocess\nimport sys\n\n# non-interactive uninstall  from Blender\u2019s Python\nsubprocess.check_call([sys.executable, \"-m\", \"pip\", \"uninstall\", \"-y\", \"polars\"])\n</pre> import subprocess import sys  # non-interactive uninstall  from Blender\u2019s Python subprocess.check_call([sys.executable, \"-m\", \"pip\", \"uninstall\", \"-y\", \"polars\"]) <pre>WARNING: Skipping polars as it is not installed.\n</pre> Out[129]: <pre>0</pre> In\u00a0[130]: Copied! <pre>#On MacOS, if uv is installed via homebrew:\nimport subprocess\ncommand = [\n    \"UV_PYTHON=python3.11\",\n    \"/opt/homebrew/bin/uv\", \"pip\", \"install\",\n    \"--prefix\", \"/Applications/Blender.app/Contents/Resources/4.3/python/\",\n    \"matplotlib\"\n]\nsubprocess.run(\" \".join(command), shell=True)\n</pre> #On MacOS, if uv is installed via homebrew: import subprocess command = [     \"UV_PYTHON=python3.11\",     \"/opt/homebrew/bin/uv\", \"pip\", \"install\",     \"--prefix\", \"/Applications/Blender.app/Contents/Resources/4.3/python/\",     \"matplotlib\" ] subprocess.run(\" \".join(command), shell=True) <pre>Using CPython 3.11.10 interpreter at: .venv/bin/python3\nAudited 1 package in 2ms\n</pre> Out[130]: <pre>CompletedProcess(args='UV_PYTHON=python3.11 /opt/homebrew/bin/uv pip install --prefix /Applications/Blender.app/Contents/Resources/4.3/python/ matplotlib', returncode=0)</pre> In\u00a0[\u00a0]: Copied! <pre># version check\nimport importlib.metadata\nprint(\"Databpy version:\", importlib.metadata.version(\"databpy\"))\n</pre> # version check import importlib.metadata print(\"Databpy version:\", importlib.metadata.version(\"databpy\"))"},{"location":"n2install_uninstall/#use-of-python-packages","title":"Use of Python Packages\u00b6","text":"<p>Install and uninstall packages.</p>"},{"location":"n3databpy1/","title":"DataBpy 1","text":"In\u00a0[104]: Copied! <pre>import bpy\nbpy.app.version_string # current blender version\n</pre> import bpy bpy.app.version_string # current blender version Out[104]: <pre>'4.4.3'</pre> In\u00a0[105]: Copied! <pre># setup for the docs\n\nimport runpy # Helper functions just for the docs\nmodule = runpy.run_path(\"/Users/jan-hendrik/projects/bpy-gallery/docs/render_utils.py\")\nglobals().update(module)\n\n\nimport sys\nfrom pathlib import Path\n#subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"polars\"])\n#subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"databpy\"])\n\n# Set render resolution\nbpy.context.scene.render.resolution_x = 500\nbpy.context.scene.render.resolution_y = 200\n\ndef camera_from_above():\n    camera = bpy.context.scene.camera\n    camera.location = (6, 4, 10)  # Position above the XY plane\n    camera.rotation_euler = (0, 0, 0)  # Rotate to look at XY plane\n    # Set the camera to orthographic mode\n    camera.data.type = 'ORTHO'\n    # Set the orthographic scale to 12\n    camera.data.ortho_scale = 9\n\n    bpy.context.scene.render.resolution_x = 300\n    bpy.context.scene.render.resolution_y = 300\n\n# use local databpy\nproject_root = Path.home() / \"projects/databpy/\"\nsys.path.append(str(project_root))\n\nimport databpy\ndatabpy.__file__\n</pre> # setup for the docs  import runpy # Helper functions just for the docs module = runpy.run_path(\"/Users/jan-hendrik/projects/bpy-gallery/docs/render_utils.py\") globals().update(module)   import sys from pathlib import Path #subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"polars\"]) #subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"databpy\"])  # Set render resolution bpy.context.scene.render.resolution_x = 500 bpy.context.scene.render.resolution_y = 200  def camera_from_above():     camera = bpy.context.scene.camera     camera.location = (6, 4, 10)  # Position above the XY plane     camera.rotation_euler = (0, 0, 0)  # Rotate to look at XY plane     # Set the camera to orthographic mode     camera.data.type = 'ORTHO'     # Set the orthographic scale to 12     camera.data.ortho_scale = 9      bpy.context.scene.render.resolution_x = 300     bpy.context.scene.render.resolution_y = 300  # use local databpy project_root = Path.home() / \"projects/databpy/\" sys.path.append(str(project_root))  import databpy databpy.__file__ Out[105]: <pre>'/Users/jan-hendrik/projects/databpy/databpy/__init__.py'</pre> In\u00a0[106]: Copied! <pre>import databpy as db\n</pre> import databpy as db In\u00a0[107]: Copied! <pre>blend_file = Path.home() / \"projects/bpy-gallery/docs/cube_gn_position.blend\"\nnode_group_name = \"gn_place_spheres\"\n\nnode_group_place_spheres = db.nodes.append_from_blend(node_group_name, blend_file)\n\nfor node in node_group_place_spheres.nodes:\n    print(node.name)\n</pre> blend_file = Path.home() / \"projects/bpy-gallery/docs/cube_gn_position.blend\" node_group_name = \"gn_place_spheres\"  node_group_place_spheres = db.nodes.append_from_blend(node_group_name, blend_file)  for node in node_group_place_spheres.nodes:     print(node.name) <pre>Appending gn_place_spheres from /Users/jan-hendrik/projects/bpy-gallery/docs/cube_gn_position.blend\nGroup Input\nGroup Output\nInstance on Points\nUV Sphere\n</pre> In\u00a0[108]: Copied! <pre>fresh_scene()\n\nimport numpy as np\nsingle_vertex = np.array([[6, 4, 0]])\n\n# Create a mesh object with the single vertex\nmy_point_obj = db.create_object(single_vertex, name=\"SinglePoint\")\n\n# Print the name of the created object\nprint(my_point_obj.name)\n\nrender_result()\n</pre> fresh_scene()  import numpy as np single_vertex = np.array([[6, 4, 0]])  # Create a mesh object with the single vertex my_point_obj = db.create_object(single_vertex, name=\"SinglePoint\")  # Print the name of the created object print(my_point_obj.name)  render_result() <pre>SinglePoint\n</pre> In\u00a0[109]: Copied! <pre>modifier = my_point_obj.modifiers.new(name=\"GeometryNodes\", type='NODES')\nmodifier.node_group = node_group_place_spheres\nrender_result()\n</pre> modifier = my_point_obj.modifiers.new(name=\"GeometryNodes\", type='NODES') modifier.node_group = node_group_place_spheres render_result() In\u00a0[110]: Copied! <pre>my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 4 # set radius\nrender_result()\n</pre> my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 4 # set radius render_result() In\u00a0[111]: Copied! <pre>import polars as pl\nurl = 'https://raw.githubusercontent.com/kolibril13/ipydrop/refs/heads/main/dino.csv'\ndf1 = pl.read_csv(url)\nlength_data = len(df1)\n\n# Scale and transform the coordinates from the dataframe\nx = df1['x'] / 10\ny = df1['y'] / 10 * 0.8\n\nprint(f\"Loaded {length_data} rows\")\ndf1.head()\n</pre> import polars as pl url = 'https://raw.githubusercontent.com/kolibril13/ipydrop/refs/heads/main/dino.csv' df1 = pl.read_csv(url) length_data = len(df1)  # Scale and transform the coordinates from the dataframe x = df1['x'] / 10 y = df1['y'] / 10 * 0.8  print(f\"Loaded {length_data} rows\") df1.head() <pre>Loaded 142 rows\n</pre> Out[111]: shape: (5, 2)xyf64f6455.384697.179551.538596.025646.153894.487242.820591.410340.769288.3333 In\u00a0[112]: Copied! <pre>fresh_scene()\n\n# Create 3D points with z=0\ncoords = np.array(list(zip(x, y, [0]*len(x))))\n\nmy_point_obj = db.create_object(coords, name=\"Deno\")\n\nmodifier = my_point_obj.modifiers.new(name=\"GeometryNodes\", type='NODES')\nmodifier.node_group = node_group_place_spheres\n\nmy_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 0.2  # Set radius\n\ncamera_from_above()\nrender_result()\n</pre> fresh_scene()  # Create 3D points with z=0 coords = np.array(list(zip(x, y, [0]*len(x))))  my_point_obj = db.create_object(coords, name=\"Deno\")  modifier = my_point_obj.modifiers.new(name=\"GeometryNodes\", type='NODES') modifier.node_group = node_group_place_spheres  my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 0.2  # Set radius  camera_from_above() render_result() In\u00a0[113]: Copied! <pre>my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 0.1  # Set radius\n\nrender_result()\n</pre> my_point_obj.modifiers[\"GeometryNodes\"][\"Socket_2\"] = 0.1  # Set radius  render_result() In\u00a0[114]: Copied! <pre># Also possible to change the data points\nimport polars as pl\nurl = 'https://raw.githubusercontent.com/kolibril13/ipydrop/refs/heads/main/star.csv'\ndf = pl.read_csv(url)\n\nx = df['x'] / 10 \ny = df['y'] / 10 * 0.8\n\ndf.head()\n</pre> # Also possible to change the data points import polars as pl url = 'https://raw.githubusercontent.com/kolibril13/ipydrop/refs/heads/main/star.csv' df = pl.read_csv(url)  x = df['x'] / 10  y = df['y'] / 10 * 0.8  df.head() Out[114]: shape: (5, 2)xyf64f6458.21360891.88189258.19605492.21498958.71823190.31053257.27837389.90760758.0820292.008145 In\u00a0[\u00a0]: Copied! <pre>coords = np.array(list(zip(x, y, [0]*len(x))))\n\ndb.store_named_attribute(my_point_obj, coords, \"position\")\nmy_point_obj.data.update()\nbpy.context.view_layer.update()\n\nrender_result()\n</pre> coords = np.array(list(zip(x, y, [0]*len(x))))  db.store_named_attribute(my_point_obj, coords, \"position\") my_point_obj.data.update() bpy.context.view_layer.update()  render_result()"},{"location":"n3databpy1/#databpy-1","title":"DataBpy 1\u00b6","text":""},{"location":"n3databpy1/#loading-pre-defined-geometry-nodes","title":"Loading Pre-Defined Geometry Nodes\u00b6","text":""},{"location":"n3databpy2/","title":"DataBpy 2","text":"In\u00a0[109]: Copied! <pre>import bpy\nprint(\"Blender version:\", bpy.app.version_string)   # current blender version\nimport importlib.metadata\nprint(\"Databpy version:\", importlib.metadata.version(\"databpy\"))\n</pre> import bpy print(\"Blender version:\", bpy.app.version_string)   # current blender version import importlib.metadata print(\"Databpy version:\", importlib.metadata.version(\"databpy\"))  <pre>Blender version: 4.4.3\nDatabpy version: 0.0.18\n</pre> In\u00a0[110]: Copied! <pre>import numpy as np\nimport databpy as db\n\nvertex = np.array([[0, 0, 0]])  \nobj = db.create_bob(vertex, name=\"Mesh1\")\nobj.name\n</pre> import numpy as np import databpy as db  vertex = np.array([[0, 0, 0]])   obj = db.create_bob(vertex, name=\"Mesh1\") obj.name Out[110]: <pre>'Mesh1'</pre> In\u00a0[111]: Copied! <pre>obj.position\n</pre> obj.position Out[111]: <pre>array([[0., 0., 0.]])</pre> In\u00a0[112]: Copied! <pre>import numpy as np\nimport databpy as db\n\ncoords = np.random.rand(20, 3)  \nobj = db.create_bob(coords, name=\"Mesh2\")\nobj.name\n</pre> import numpy as np import databpy as db  coords = np.random.rand(20, 3)   obj = db.create_bob(coords, name=\"Mesh2\") obj.name Out[112]: <pre>'Mesh2'</pre> In\u00a0[113]: Copied! <pre>obj.position[:3] # first three\n</pre> obj.position[:3] # first three Out[113]: <pre>array([[0.85635167, 0.50563103, 0.94801462],\n       [0.98673707, 0.94620389, 0.14079188],\n       [0.40638462, 0.20826402, 0.07702765]])</pre> In\u00a0[114]: Copied! <pre>%%time\nimport numpy as np\nimport databpy as db\n\n# Generate 2 million random 3D points\ncoords = np.random.rand(2_000_000, 3)\n\n# Create a mesh object using databpy\nobj = db.create_bob(coords, name=\"Mesh2M\")\nprint(obj.name)\n</pre> %%time import numpy as np import databpy as db  # Generate 2 million random 3D points coords = np.random.rand(2_000_000, 3)  # Create a mesh object using databpy obj = db.create_bob(coords, name=\"Mesh2M\") print(obj.name) <pre>Mesh2M\nCPU times: user 711 ms, sys: 44.5 ms, total: 755 ms\nWall time: 760 ms\n</pre> In\u00a0[115]: Copied! <pre>import numpy as np\nimport polars as pl\nfrom csv_importer.parsers import polars_df_to_bob\n\ndf = pl.DataFrame(\n    {\n        \"Intensity\": [10, 20],\n    }\n)\nbob = polars_df_to_bob(df, name=\"MeshInt\")\n</pre> import numpy as np import polars as pl from csv_importer.parsers import polars_df_to_bob  df = pl.DataFrame(     {         \"Intensity\": [10, 20],     } ) bob = polars_df_to_bob(df, name=\"MeshInt\") In\u00a0[116]: Copied! <pre>import numpy as np\nimport polars as pl\nfrom csv_importer.parsers import polars_df_to_bob\n\ndf = pl.DataFrame(\n    {\n        \"opacity\": [0.34, 0.92],\n    }\n)\nbob = polars_df_to_bob(df, name=\"MeshFloat\")\n</pre> import numpy as np import polars as pl from csv_importer.parsers import polars_df_to_bob  df = pl.DataFrame(     {         \"opacity\": [0.34, 0.92],     } ) bob = polars_df_to_bob(df, name=\"MeshFloat\") In\u00a0[117]: Copied! <pre>import numpy as np\nimport polars as pl\nfrom csv_importer.parsers import polars_df_to_bob\n\ndf = pl.DataFrame(\n    {\n        \"Is_Visible\": [True, False],\n    }\n)\nbob = polars_df_to_bob(df, name=\"MeshBool\")\n</pre> import numpy as np import polars as pl from csv_importer.parsers import polars_df_to_bob  df = pl.DataFrame(     {         \"Is_Visible\": [True, False],     } ) bob = polars_df_to_bob(df, name=\"MeshBool\") In\u00a0[118]: Copied! <pre>import numpy as np\nimport polars as pl\nfrom csv_importer.parsers import polars_df_to_bob\n\ndf = pl.DataFrame({\n    \"Star\": [\n        [3.4, 3.5, 0.0],\n        [3.1, 5.6, 0.0]\n    ]\n})\nobj = polars_df_to_bob(df, name=\"MeshVector\")\n</pre> import numpy as np import polars as pl from csv_importer.parsers import polars_df_to_bob  df = pl.DataFrame({     \"Star\": [         [3.4, 3.5, 0.0],         [3.1, 5.6, 0.0]     ] }) obj = polars_df_to_bob(df, name=\"MeshVector\") In\u00a0[119]: Copied! <pre>import numpy as np\nimport polars as pl\nfrom csv_importer.parsers import polars_df_to_bob\n\ndf = pl.DataFrame({\n    \"String\": [\"Hello\", \"World\"],\n})\n# Stings are not supported\nobj = polars_df_to_bob(df, name=\"MeshVector\")\n</pre> import numpy as np import polars as pl from csv_importer.parsers import polars_df_to_bob  df = pl.DataFrame({     \"String\": [\"Hello\", \"World\"], }) # Stings are not supported obj = polars_df_to_bob(df, name=\"MeshVector\") In\u00a0[120]: Copied! <pre># all together\nimport numpy as np\nimport polars as pl\nfrom csv_importer.parsers import polars_df_to_bob\n\ndf = pl.DataFrame({\n    \"Intensity\": [10, 20],\n    \"opacity\": [0.34, 0.92],\n    \"Is_Visible\": [True, False],\n    \"Star\": [\n        [3.4, 3.5, 0.0],\n        [3.1, 5.6, 0.0]\n    ]\n})\nobj = polars_df_to_bob(df, name=\"MeshVector\")\n</pre> # all together import numpy as np import polars as pl from csv_importer.parsers import polars_df_to_bob  df = pl.DataFrame({     \"Intensity\": [10, 20],     \"opacity\": [0.34, 0.92],     \"Is_Visible\": [True, False],     \"Star\": [         [3.4, 3.5, 0.0],         [3.1, 5.6, 0.0]     ] }) obj = polars_df_to_bob(df, name=\"MeshVector\") In\u00a0[123]: Copied! <pre>from pathlib import Path\nfrom csv_importer.csv import load_csv\n\ncsv_path = Path.home() / \"projects\" / \"blender_csv_import\" / \"docs\" / \"sample_datasets\" / \"data_california_housing_normalized.csv\"\n\n# `load_csv` is like `like polars_df_to_bob`, but with a csv path input\nobj = load_csv(csv_path) \n \nprint(obj.name)\n</pre> from pathlib import Path from csv_importer.csv import load_csv  csv_path = Path.home() / \"projects\" / \"blender_csv_import\" / \"docs\" / \"sample_datasets\" / \"data_california_housing_normalized.csv\"  # `load_csv` is like `like polars_df_to_bob`, but with a csv path input obj = load_csv(csv_path)    print(obj.name) <pre>CSV_data_california_housing_normalized\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"n3databpy2/#databpy-2","title":"DataBpy 2\u00b6","text":"<p>https://github.com/BradyAJohnston/databpy</p>"},{"location":"n3databpy2/#setting-attributes","title":"Setting Attributes\u00b6","text":"<p>To run the code below, first install the Blender extension from the following link: https://extensions.blender.org/add-ons/csv-importer/</p>"},{"location":"n4typst_examples/","title":"Typst","text":"<p>Table of Contents</p> <ol> <li>Basic Equation</li> <li>Function arguments</li> <li>Integration Example</li> <li>Using Color in Equations</li> <li>More symbols</li> <li>Accessing SVG</li> <li>Code Block Rendering</li> </ol> <p>Link to extension: https://extensions.blender.org/add-ons/typst-importer/</p> In\u00a0[6]: Copied! <pre>import typst\ntypst.__version__\n</pre> import typst typst.__version__ Out[6]: <pre>'0.13.1'</pre> In\u00a0[7]: Copied! <pre># Import helper functions just for the docs\nimport runpy\nmodule = runpy.run_path(\"/Users/jan-hendrik/projects/bpy-gallery/docs/render_utils.py\")\nglobals().update(module) # adds fresh_scene(), render_result(), load_paper_background()\nload_paper_background()\n</pre> # Import helper functions just for the docs import runpy module = runpy.run_path(\"/Users/jan-hendrik/projects/bpy-gallery/docs/render_utils.py\") globals().update(module) # adds fresh_scene(), render_result(), load_paper_background() load_paper_background() In\u00a0[50]: Copied! <pre>from typst_importer.typst_to_svg import typst_express\nfresh_scene()\n\nc = typst_express(\n    \"$ a = b/c$\",\n)\nrender_result(collection=c)\n</pre> from typst_importer.typst_to_svg import typst_express fresh_scene()  c = typst_express(     \"$ a = b/c$\", ) render_result(collection=c) In\u00a0[51]: Copied! <pre>fresh_scene()\nc = typst_express(\n    \"$ e = m c^2$\",\n    scale_factor=300,\n    join_curves=True, \n    origin_to_char=False,\n    name=\"Einstein's Equation\"\n)\nrender_result(collection=c)\n</pre> fresh_scene() c = typst_express(     \"$ e = m c^2$\",     scale_factor=300,     join_curves=True,      origin_to_char=False,     name=\"Einstein's Equation\" ) render_result(collection=c) In\u00a0[52]: Copied! <pre>fresh_scene()\ncontent = \"$ limits(integral)_a^b f(x) dif x $\" \nc = typst_express(content, join_curves=True, name=\"Integral\")\nrender_result(collection=c)\n</pre> fresh_scene() content = \"$ limits(integral)_a^b f(x) dif x $\"  c = typst_express(content, join_curves=True, name=\"Integral\") render_result(collection=c) In\u00a0[53]: Copied! <pre>fresh_scene()\nc = typst_express(\"\"\"\n#let korange() = text(fill: orange)[$k$]\n#let nblue() = text(fill: blue)[$n$]\n$ sum_(#korange() = 1)^#nblue() #korange() = (nblue()(nblue()+1)) / 2 $  \n\"\"\")\nrender_result(collection=c, width=\"600pt\")\n</pre> fresh_scene() c = typst_express(\"\"\" #let korange() = text(fill: orange)[$k$] #let nblue() = text(fill: blue)[$n$] $ sum_(#korange() = 1)^#nblue() #korange() = (nblue()(nblue()+1)) / 2 $   \"\"\") render_result(collection=c, width=\"600pt\") In\u00a0[54]: Copied! <pre>fresh_scene()\ncontent = \"\"\"\n#set math.lr(size: 80%)\n$ integral.triple _V (nabla dot accent(F, arrow)) dif V = integral.surf_(partial V)  (accent(F, arrow) dot accent(n, arrow)) dif A $\n\"\"\"\nc = typst_express(content)\nrender_result(collection=c , padding_factor=-0.4, width=\"1200pt\")\n</pre> fresh_scene() content = \"\"\" #set math.lr(size: 80%) $ integral.triple _V (nabla dot accent(F, arrow)) dif V = integral.surf_(partial V)  (accent(F, arrow) dot accent(n, arrow)) dif A $ \"\"\" c = typst_express(content) render_result(collection=c , padding_factor=-0.4, width=\"1200pt\") In\u00a0[55]: Copied! <pre>from typst_importer.notebook_utils import display_svg\nprint(f\"...{c.processed_svg[490:550]}...\")\ndisplay_svg(c.processed_svg, width=\"400pt\")\n</pre> from typst_importer.notebook_utils import display_svg print(f\"...{c.processed_svg[490:550]}...\") display_svg(c.processed_svg, width=\"400pt\") <pre>...=\"#000000\" fill-rule=\"nonzero\"&gt;&lt;path d=\"M 83.55 68.05 C 81.2...\n</pre> In\u00a0[56]: Copied! <pre>fresh_scene()   \nc = typst_express(\"\"\"\n#set page(width: 500pt, height: auto, margin: 0cm, fill: none)\n\n#import \"@preview/codelst:2.0.2\": sourcecode\n#import \"@preview/tablex:0.0.8\": tablex\n#let sourcecode = sourcecode.with(frame: (code) =&gt; block(\n  radius: 5pt,\n  stroke: 2pt + luma(0),\n  inset: 30pt,\n  text(size: 30pt, code)\n))\n\n#sourcecode[```python\nfor i in range(0,10):\n  print(i)\n```]\n\"\"\")\nrender_result(collection=c, padding_factor=-0.4, width=\"900pt\")\n</pre> fresh_scene()    c = typst_express(\"\"\" #set page(width: 500pt, height: auto, margin: 0cm, fill: none)  #import \"@preview/codelst:2.0.2\": sourcecode #import \"@preview/tablex:0.0.8\": tablex #let sourcecode = sourcecode.with(frame: (code) =&gt; block(   radius: 5pt,   stroke: 2pt + luma(0),   inset: 30pt,   text(size: 30pt, code) ))  #sourcecode[```python for i in range(0,10):   print(i) ```] \"\"\") render_result(collection=c, padding_factor=-0.4, width=\"900pt\") In\u00a0[57]: Copied! <pre>fresh_scene()\ncontent = \"\"\"\n#set page(width: 800pt, height: auto, margin: 0cm, fill: none)\n\n#import \"@preview/codelst:2.0.2\": sourcecode\n#import \"@preview/tablex:0.0.8\": tablex\n\n#let sourcecode = sourcecode.with(frame: (code) =&gt; block(\n  radius: 5pt,\n  stroke: 5pt + luma(0),\n  inset: 30pt,\n  text(size: 30pt, code)\n))\n\n#sourcecode[```python\n\nclass HelloWorld:\n    def __init__(self):\n        self.message = \"Hello, world!\"\n\n    def greet(self):\n        print(self.message)\n\nif __name__ == \"__main__\":\n    hello = HelloWorld()\n    hello.greet()\n```]\n\"\"\"\nc = typst_express(content)\nrender_result(collection=c , padding_factor=-0.4, width=\"800pt\")\n</pre> fresh_scene() content = \"\"\" #set page(width: 800pt, height: auto, margin: 0cm, fill: none)  #import \"@preview/codelst:2.0.2\": sourcecode #import \"@preview/tablex:0.0.8\": tablex  #let sourcecode = sourcecode.with(frame: (code) =&gt; block(   radius: 5pt,   stroke: 5pt + luma(0),   inset: 30pt,   text(size: 30pt, code) ))  #sourcecode[```python  class HelloWorld:     def __init__(self):         self.message = \"Hello, world!\"      def greet(self):         print(self.message)  if __name__ == \"__main__\":     hello = HelloWorld()     hello.greet() ```] \"\"\" c = typst_express(content) render_result(collection=c , padding_factor=-0.4, width=\"800pt\") In\u00a0[58]: Copied! <pre>fresh_scene()\ncontent = \"\"\"\n#set math.lr(size: 80%)\n$ mat(1, 2; 3, 4) $\"\"\"\nc = typst_express(content)\nrender_result(collection=c , padding_factor=-0.4, width=\"200pt\")\n</pre> fresh_scene() content = \"\"\" #set math.lr(size: 80%) $ mat(1, 2; 3, 4) $\"\"\" c = typst_express(content) render_result(collection=c , padding_factor=-0.4, width=\"200pt\") In\u00a0[59]: Copied! <pre>fresh_scene()\ncontent = \"\"\"\n$ f(x) = 4x^2 + 5x + 6 $\n\"\"\"\nc = typst_express(content)\nrender_result(collection=c , padding_factor=-0.4, width=\"200pt\")\n</pre> fresh_scene() content = \"\"\" $ f(x) = 4x^2 + 5x + 6 $ \"\"\" c = typst_express(content) render_result(collection=c , padding_factor=-0.4, width=\"200pt\") In\u00a0[60]: Copied! <pre>fresh_scene()\neq1 = \"\"\"\nHello\n\"\"\"\n\neq2 = \"\"\"\nWorld\n\"\"\"\n\nc1 = typst_express(\n    eq1,\n    origin_to_char=True,\n    name=\"Term1\",\n    position=(0, 0, 0),  # Place at origin\n)\n\nc2 = typst_express(\n    eq2,\n    origin_to_char=True,\n    name=\"Term2\",\n    position=(2, 2, 0),  # Place 2 units to the right\n)\n\n\nrender_result(collection=[c1, c2], padding_factor=-0.4, width=\"200pt\")\n</pre> fresh_scene() eq1 = \"\"\" Hello \"\"\"  eq2 = \"\"\" World \"\"\"  c1 = typst_express(     eq1,     origin_to_char=True,     name=\"Term1\",     position=(0, 0, 0),  # Place at origin )  c2 = typst_express(     eq2,     origin_to_char=True,     name=\"Term2\",     position=(2, 2, 0),  # Place 2 units to the right )   render_result(collection=[c1, c2], padding_factor=-0.4, width=\"200pt\") In\u00a0[61]: Copied! <pre>fresh_scene()\n\neq = \"\"\"\n#set text(black)\n$ a = b + r $\n\"\"\"\nc = typst_express( eq, origin_to_char=True, name=\"Term1\")\nrender_result(collection=c , padding_factor=-0.4, width=\"200pt\")\n</pre> fresh_scene()  eq = \"\"\" #set text(black) $ a = b + r $ \"\"\" c = typst_express( eq, origin_to_char=True, name=\"Term1\") render_result(collection=c , padding_factor=-0.4, width=\"200pt\") In\u00a0[62]: Copied! <pre>fresh_scene()\n\neq = \"\"\"\n#set text(orange)\n$ a = b + c $\n\"\"\"\nc = typst_express( eq, origin_to_char=True, name=\"Term2\")\nrender_result(collection=c, padding_factor=-0.4, width=\"200pt\")\n</pre> fresh_scene()  eq = \"\"\" #set text(orange) $ a = b + c $ \"\"\" c = typst_express( eq, origin_to_char=True, name=\"Term2\") render_result(collection=c, padding_factor=-0.4, width=\"200pt\") In\u00a0[63]: Copied! <pre>fresh_scene()\ndef eq(equation: str, name: str, color: str, position=(0, 0, 0)):\n\n    typst_code = f\"\"\"\n    #set text({color})\n    $ {equation} $\n    \"\"\"\n    collection = typst_express(\n        typst_code,\n        origin_to_char=True,\n        convert_to_mesh=False,\n        name=name,\n        position=position\n    )\n\n    return collection\n\n\nc1 = eq(\"a -b = c\", \"Start\", \"aqua\", (0, -5, 0.5))\nc2 = eq(\"a - 3 r_(beta) = c\", \"End\", \"olive\", (0, -4, 0));\n\n\n\nrender_result(collection=[c1, c2] , padding_factor=-0.4, width=\"200pt\")\n</pre> fresh_scene() def eq(equation: str, name: str, color: str, position=(0, 0, 0)):      typst_code = f\"\"\"     #set text({color})     $ {equation} $     \"\"\"     collection = typst_express(         typst_code,         origin_to_char=True,         convert_to_mesh=False,         name=name,         position=position     )      return collection   c1 = eq(\"a -b = c\", \"Start\", \"aqua\", (0, -5, 0.5)) c2 = eq(\"a - 3 r_(beta) = c\", \"End\", \"olive\", (0, -4, 0));    render_result(collection=[c1, c2] , padding_factor=-0.4, width=\"200pt\") In\u00a0[64]: Copied! <pre>from typst_importer.typst_to_svg import typst_express\n\ncontent = \"\"\"\n$ integral f(x) dif x $\n\"\"\"\n\nc1 = typst_express(content, origin_to_char=True, position=(0, 1.4, 0), name=\"A1\")\n\n\ncontent = \"\"\"\n#show math.equation: set text(font: \"STIX Two Math\")\n$ integral f(x) dif x $\n\"\"\"\n\nc2 = typst_express(content, origin_to_char=True, position=(0, 0, 0), name=\"A2\")\n\nrender_result(collection=[c1, c2] , padding_factor=-0.4, width=\"200pt\")\n</pre> from typst_importer.typst_to_svg import typst_express  content = \"\"\" $ integral f(x) dif x $ \"\"\"  c1 = typst_express(content, origin_to_char=True, position=(0, 1.4, 0), name=\"A1\")   content = \"\"\" #show math.equation: set text(font: \"STIX Two Math\") $ integral f(x) dif x $ \"\"\"  c2 = typst_express(content, origin_to_char=True, position=(0, 0, 0), name=\"A2\")  render_result(collection=[c1, c2] , padding_factor=-0.4, width=\"200pt\") In\u00a0[10]: Copied! <pre>from typst_importer.typst_to_svg import typst_express\n\n# General quadratic equation\nc1 = typst_express(\"$ x^2 + p x + q = 0 $\", origin_to_char=True, position=(0, 0, 0), name=\"Step1\")\n\n# Step 1: Complete the square\nc2 = typst_express(\"$ x^2 + p x = -q $\", origin_to_char=True, position=(0, -1.5, -1), name=\"Step2\")\n\n# Step 2: Add and subtract (p/2)^2 on the left side\nc3 = typst_express(\"$ x^2 + p x + (p/2)^2 = -q + (p/2)^2 $\", origin_to_char=True, position=(0, -3, -2), name=\"Step3\")\n\n# Step 3: Rewrite as squared binomial\nc4 = typst_express(\"$ (x + p/2)^2 = (p/2)^2 - q $\", origin_to_char=True, position=(0, -4.5, -3), name=\"Step4\")\n\n# Step 4: Square root both sides\nc5 = typst_express(\"$ x + p/2 = plus.minus sqrt((p/2)^2 - q) $\", origin_to_char=True, position=(0, -6, -4), name=\"Step5\")\n\n# Step 5: Solve explicitly for x\nc6 = typst_express(\"$ x_(1,2) = -p/2 plus.minus sqrt((p/2)^2 - q) $\", origin_to_char=True, position=(0, -7.5, -5), name=\"Step6\")\n\n# Render all steps\nrender_result(collection=[c1, c2, c3, c4, c5, c6], padding_factor=-0.4, width=\"600pt\")\n</pre> from typst_importer.typst_to_svg import typst_express  # General quadratic equation c1 = typst_express(\"$ x^2 + p x + q = 0 $\", origin_to_char=True, position=(0, 0, 0), name=\"Step1\")  # Step 1: Complete the square c2 = typst_express(\"$ x^2 + p x = -q $\", origin_to_char=True, position=(0, -1.5, -1), name=\"Step2\")  # Step 2: Add and subtract (p/2)^2 on the left side c3 = typst_express(\"$ x^2 + p x + (p/2)^2 = -q + (p/2)^2 $\", origin_to_char=True, position=(0, -3, -2), name=\"Step3\")  # Step 3: Rewrite as squared binomial c4 = typst_express(\"$ (x + p/2)^2 = (p/2)^2 - q $\", origin_to_char=True, position=(0, -4.5, -3), name=\"Step4\")  # Step 4: Square root both sides c5 = typst_express(\"$ x + p/2 = plus.minus sqrt((p/2)^2 - q) $\", origin_to_char=True, position=(0, -6, -4), name=\"Step5\")  # Step 5: Solve explicitly for x c6 = typst_express(\"$ x_(1,2) = -p/2 plus.minus sqrt((p/2)^2 - q) $\", origin_to_char=True, position=(0, -7.5, -5), name=\"Step6\")  # Render all steps render_result(collection=[c1, c2, c3, c4, c5, c6], padding_factor=-0.4, width=\"600pt\") In\u00a0[13]: Copied! <pre>fresh_scene()\n\ncontent = \"$ a * b = c $\"\nc1 = typst_express(content, origin_to_char=True, position=(0, 0, 0), name=\"A1\")\n\n\ncontent = \"$ a  = c / b  $\"\nc2 = typst_express(content, origin_to_char=True, position=(0, -1.5, -0.7), name=\"A2\")\n\n\n\nrender_result(collection=[c1, c2], padding_factor=-0.4, width=\"200pt\")\n</pre> fresh_scene()  content = \"$ a * b = c $\" c1 = typst_express(content, origin_to_char=True, position=(0, 0, 0), name=\"A1\")   content = \"$ a  = c / b  $\" c2 = typst_express(content, origin_to_char=True, position=(0, -1.5, -0.7), name=\"A2\")    render_result(collection=[c1, c2], padding_factor=-0.4, width=\"200pt\")  <pre>[I 2025-04-03 15:14:24.809 ServerApp] 302 GET / (@127.0.0.1) 0.78ms\n[I 2025-04-03 15:14:24.810 LabApp] 302 GET /lab? (@127.0.0.1) 0.53ms\n[I 2025-04-03 15:14:24.851 ServerApp] Kernel started: 73680cae-af4e-401c-8fc5-36086b283b2b\n</pre>"},{"location":"n4typst_examples/#typst","title":"Typst\u00b6","text":""},{"location":"render_utils/","title":"Render utils","text":"In\u00a0[\u00a0]: Copied! <pre>import bpy\nfrom IPython.display import Image, display\nfrom mathutils import Vector\nfrom pathlib import Path\n# from typst_importer.curve_utils import get_curve_collection_bounds\nimport tempfile\nfrom math import radians\n</pre> import bpy from IPython.display import Image, display from mathutils import Vector from pathlib import Path # from typst_importer.curve_utils import get_curve_collection_bounds import tempfile from math import radians In\u00a0[\u00a0]: Copied! <pre>def fresh_scene(keep_cube=False):\n    bpy.ops.object.select_all(action='DESELECT')\n    # Keep only Plane, Camera and Sun\n    for obj in bpy.context.scene.objects:\n        if obj.name not in ['PlaneBG', 'Camera', 'Sun']:\n            obj.select_set(True)\n    bpy.ops.object.delete()\n    for collection in bpy.data.collections:\n        if collection.name != \"Collection\":\n            bpy.data.collections.remove(collection)\n    \n    # Add a light source if it doesn't exist\n    if 'Sun' not in bpy.context.scene.objects:\n        bpy.ops.object.light_add(type='SUN')\n        sun = bpy.context.active_object\n        sun.location = (0, 0, 0)\n        sun.rotation_euler = (radians(204), radians(-133), radians(-67))\n        sun.data.energy = 3\n</pre> def fresh_scene(keep_cube=False):     bpy.ops.object.select_all(action='DESELECT')     # Keep only Plane, Camera and Sun     for obj in bpy.context.scene.objects:         if obj.name not in ['PlaneBG', 'Camera', 'Sun']:             obj.select_set(True)     bpy.ops.object.delete()     for collection in bpy.data.collections:         if collection.name != \"Collection\":             bpy.data.collections.remove(collection)          # Add a light source if it doesn't exist     if 'Sun' not in bpy.context.scene.objects:         bpy.ops.object.light_add(type='SUN')         sun = bpy.context.active_object         sun.location = (0, 0, 0)         sun.rotation_euler = (radians(204), radians(-133), radians(-67))         sun.data.energy = 3 In\u00a0[\u00a0]: Copied! <pre>def adjust_camera_to_collection(c, padding_factor=-0.2):\n    min_p, max_p = get_curve_collection_bounds(c)\n    center = (min_p + max_p) / 2\n    size = max_p - min_p\n    padded_size = size * (1 + padding_factor)\n    padded_max_dim = max(padded_size.x, padded_size.y, padded_size.z)\n\n    if 'Camera' not in bpy.data.objects:\n        bpy.ops.object.camera_add()\n        camera = bpy.data.objects['Camera']\n    else:\n        camera = bpy.data.objects['Camera']\n    \n    bpy.context.scene.camera = camera\n    camera.location = (center.x, center.y, center.z + padded_max_dim*2)\n    camera.rotation_euler = (0, 0, 0)\n    camera.data.type = 'ORTHO'\n    camera.data.ortho_scale = padded_max_dim * 2\n    aspect_ratio = padded_size.x / padded_size.y\n    bpy.context.scene.render.resolution_x = 960\n    bpy.context.scene.render.resolution_y = int(960 / aspect_ratio)\n</pre> def adjust_camera_to_collection(c, padding_factor=-0.2):     min_p, max_p = get_curve_collection_bounds(c)     center = (min_p + max_p) / 2     size = max_p - min_p     padded_size = size * (1 + padding_factor)     padded_max_dim = max(padded_size.x, padded_size.y, padded_size.z)      if 'Camera' not in bpy.data.objects:         bpy.ops.object.camera_add()         camera = bpy.data.objects['Camera']     else:         camera = bpy.data.objects['Camera']          bpy.context.scene.camera = camera     camera.location = (center.x, center.y, center.z + padded_max_dim*2)     camera.rotation_euler = (0, 0, 0)     camera.data.type = 'ORTHO'     camera.data.ortho_scale = padded_max_dim * 2     aspect_ratio = padded_size.x / padded_size.y     bpy.context.scene.render.resolution_x = 960     bpy.context.scene.render.resolution_y = int(960 / aspect_ratio) In\u00a0[\u00a0]: Copied! <pre>def render_result(width=\"300pt\", collection=None, padding_factor=-0.2):\n    if collection is not None:\n        if isinstance(collection, list):\n            # Merge collections temporarily for rendering\n            temp_collection = bpy.data.collections.new(\"TempRenderCollection\")\n            bpy.context.scene.collection.children.link(temp_collection)\n            \n            for c in collection:\n                for obj in c.objects:\n                    temp_collection.objects.link(obj)\n            \n            adjust_camera_to_collection(temp_collection, padding_factor)\n            \n            # Clean up after rendering\n            bpy.context.scene.collection.children.unlink(temp_collection)\n            bpy.data.collections.remove(temp_collection)\n        else:\n            adjust_camera_to_collection(collection, padding_factor)\n        \n    with tempfile.TemporaryDirectory() as tmpdir:\n        output_path = str(Path(tmpdir) / 'img.png')\n        bpy.ops.render.render()\n        bpy.data.images['Render Result'].save_render(filepath=output_path)\n        display(Image(filename=output_path, width=width, height=\"auto\"))\n</pre> def render_result(width=\"300pt\", collection=None, padding_factor=-0.2):     if collection is not None:         if isinstance(collection, list):             # Merge collections temporarily for rendering             temp_collection = bpy.data.collections.new(\"TempRenderCollection\")             bpy.context.scene.collection.children.link(temp_collection)                          for c in collection:                 for obj in c.objects:                     temp_collection.objects.link(obj)                          adjust_camera_to_collection(temp_collection, padding_factor)                          # Clean up after rendering             bpy.context.scene.collection.children.unlink(temp_collection)             bpy.data.collections.remove(temp_collection)         else:             adjust_camera_to_collection(collection, padding_factor)              with tempfile.TemporaryDirectory() as tmpdir:         output_path = str(Path(tmpdir) / 'img.png')         bpy.ops.render.render()         bpy.data.images['Render Result'].save_render(filepath=output_path)         display(Image(filename=output_path, width=width, height=\"auto\")) In\u00a0[\u00a0]: Copied! <pre>def load_paper_background():\n    path = Path.home() / \"projects/bpy-gallery/docs/paper_background.blend\"\n    filepath = str(path)\n    \n    with bpy.data.libraries.load(filepath, link=False) as (data_from, data_to):\n        data_to.objects = data_from.objects\n\n    for obj in data_to.objects:\n        if obj is not None:\n            bpy.context.collection.objects.link(obj)\n</pre> def load_paper_background():     path = Path.home() / \"projects/bpy-gallery/docs/paper_background.blend\"     filepath = str(path)          with bpy.data.libraries.load(filepath, link=False) as (data_from, data_to):         data_to.objects = data_from.objects      for obj in data_to.objects:         if obj is not None:             bpy.context.collection.objects.link(obj)"}]}